{
  "title": "Scalable Multi-Agent Chat Using @mentions",
  "url": "https://n8n.io/workflows/3473-scalable-multi-agent-chat-using-mentions/",
  "category": "BuildingBlocks",
  "category_url": "https://n8n.io/workflows/categories/building-blocks/?sort=createdAt:desc",
  "author": "Jon Doran",
  "publish_date": "Last update a month ago",
  "publish_date_absolute": "",
  "content": "",
  "workflow_json": "{\"id\":\"0QQxgdQABUbbDJ0G\",\"meta\":{\"instanceId\":\"c98909b50b05c4069bd93ee5a4753d07322c9680e81da8568e96de2c713adb5c\"},\"name\":\"Multi-Agent Conversation\",\"tags\":[],\"nodes\":[{\"id\":\"218308e2-dc68-43ee-ae84-d931ad7a4ac5\",\"name\":\"When chat message received\",\"type\":\"@n8n/n8n-nodes-langchain.chatTrigger\",\"position\":[-1880,-3280],\"webhookId\":\"a74752f3-419a-4510-856f-3efeaceec019\",\"parameters\":{\"options\":{}},\"typeVersion\":1.1},{\"id\":\"a519fe1e-8739-46e0-9770-deb256ab96cf\",\"name\":\"AI Agent\",\"type\":\"@n8n/n8n-nodes-langchain.agent\",\"position\":[-340,-3280],\"parameters\":{\"text\":\"={{ $json.chatInput }}\",\"options\":{\"systemMessage\":\"=Current date is {{ $now.format('yyyy-MM-dd') }}. The current time is {{ $now.format('HH:MM:ss') }}.\\n\\nThe user is {{ $('Define Global Settings').item.json.user.name }}, based in {{ $('Define Global Settings').item.json.user.location }}. {{ $('Define Global Settings').item.json.user.notes }}\\n\\nYou are part of a conversation with a user and multiple AI Assistants: {{ $('Define Agent Settings').item.json.keys() }}\\n\\nYou are {{ $('First loop?').item.json.name }}.\\n\\n{{ $('Loop Over Items').item.json.systemMessage }}\\n\\n{{ $('Define Global Settings').item.json.global.systemMessage }}\"},\"promptType\":\"define\"},\"typeVersion\":1.8},{\"id\":\"2e00f0ff-e7af-45d5-99bc-23031b5d7892\",\"name\":\"Loop Over Items\",\"type\":\"n8n-nodes-base.splitInBatches\",\"position\":[-1000,-3280],\"parameters\":{\"options\":{}},\"typeVersion\":3},{\"id\":\"1c979a20-46a5-4591-92da-82c1c96277c6\",\"name\":\"Extract mentions\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1220,-3280],\"parameters\":{\"jsCode\":\"// Analyzes the user message and extracts @mentions in the order they appear. If there are none, all Assistants will be called in random order.\\n// --- Configuration: Adjust these lines ---\\nconst chatMessageNodeName = 'When chat message received'; // <-- Replace with your Chat Message node name\\nconst agentSetupNodeName = 'Define Agent Settings';         // <-- Replace with your Agent Setup node name\\nconst chatTextPath = 'json.chatInput';               // <-- Replace with path to text in Chat node output (e.g., 'json.message')\\n// --- End Configuration ---\\n\\n// Helper function for safe nested property access (alternative to _.get)\\nfunction getSafe(obj, path, defaultValue = undefined) {\\n    const pathParts = path.split('.');\\n    let current = obj;\\n    for (const part of pathParts) {\\n        if (current === null || current === undefined || typeof current !== 'object' || !Object.prototype.hasOwnProperty.call(current, part)) {\\n            return defaultValue;\\n        }\\n        current = current[part];\\n    }\\n    return current ?? defaultValue;\\n}\\n\\n// 1. Get Chat Text\\nconst chatMessageNode = $(chatMessageNodeName);\\nconst chatText = getSafe(chatMessageNode.item, chatTextPath, '');\\n\\n// 2. Get Agent Data and Names\\nconst agentSetupNode = $(agentSetupNodeName);\\nconst agentData = getSafe(agentSetupNode.item, 'json', {}); // e.g., { Chad: {...}, Gemma: {...}, Claude: {...} }\\nconst agentNames = Object.keys(agentData);\\n\\n// 3. Find all mentions, their names, and their positions in the text\\nconst foundMentions = [];\\nif (chatText && agentNames.length > 0) {\\n    const escapeRegex = (s) => s.replace(/[-\\\\/\\\\\\\\^$*+?.()|[\\\\]{}]/g, '\\\\\\\\$&');\\n    const agentPatternPart = agentNames.map(escapeRegex).join('|');\\n\\n    if (agentPatternPart) {\\n        const mentionPattern = new RegExp(`\\\\\\\\B@(${agentPatternPart})\\\\\\\\b`, 'gi');\\n        const matches = chatText.matchAll(mentionPattern);\\n\\n        for (const match of matches) {\\n            const matchedNameCaseInsensitive = match[1];\\n            const matchIndex = match.index;\\n            const canonicalName = agentNames.find(name => name.toLowerCase() === matchedNameCaseInsensitive.toLowerCase());\\n            if (canonicalName) {\\n                foundMentions.push({ name: canonicalName, index: matchIndex });\\n            }\\n        }\\n    }\\n}\\n\\n// 4. Sort the found mentions by their index (order of appearance)\\nfoundMentions.sort((a, b) => a.index - b.index);\\n\\n// 5. Map the sorted mentions to the desired output format (array of agent detail objects)\\nlet outputArray = foundMentions.map(mention => {\\n    const agentDetails = agentData[mention.name];\\n    if (!agentDetails) {\\n        console.warn(`Could not find details for agent: ${mention.name}`);\\n        return null;\\n    }\\n    return {\\n        name: agentDetails.name,\\n        model: agentDetails.model,\\n        systemMessage: agentDetails.systemMessage\\n    };\\n}).filter(item => item !== null);\\n\\n// 6. Check if any mentions were specifically found. If not, populate outputArray with ALL agents in RANDOM order.\\nif (outputArray.length === 0 && foundMentions.length === 0) { // Check if NO mentions were found initially\\n    // --- NO MENTIONS FOUND ---\\n    // Populate outputArray with ALL agents from agentData\\n    const allAgentDetailsArray = Object.values(agentData);\\n\\n    // --- Simple Randomization ---\\n    // Shuffle the array in place using sort with a random comparator\\n    allAgentDetailsArray.sort(() => 0.5 - Math.random());\\n    // --- End Randomization ---\\n\\n    // Map all agents (now in random order) to the output structure\\n    outputArray = allAgentDetailsArray.map(agentObject => ({\\n        name: agentObject.name,\\n        model: agentObject.model,\\n        systemMessage: agentObject.systemMessage\\n    }));\\n} // Intentionally no 'else' here, if outputArray already had items from mentions, we use that.\\n\\n// 7. Final Output Formatting (Handles both cases: specific mentions OR all agents)\\n// Check if, after everything, the outputArray is *still* empty (e.g., if agentData was empty initially)\\nif (outputArray.length === 0) {\\n    // If still empty, return a status or error as a fallback\\n     return [{ json: { status: \\\"no_agents_available\\\", message: \\\"No mentions found and no agents defined.\\\" } }];\\n} else {\\n    // Return the array of agent objects formatted for n8n (multiple items)\\n    return outputArray.map(agentObject => ({ json: agentObject }));\\n}\"},\"typeVersion\":2},{\"id\":\"45f635ca-f4fa-4f6c-a32a-9722906255fd\",\"name\":\"Simple Memory\",\"type\":\"@n8n/n8n-nodes-langchain.memoryBufferWindow\",\"position\":[-192,-3060],\"parameters\":{\"sessionKey\":\"={{ $('When chat message received').first().json.sessionId }}\",\"sessionIdType\":\"customKey\",\"contextWindowLength\":99},\"typeVersion\":1.3},{\"id\":\"5c903044-bce2-4aa8-b168-a460a4999c54\",\"name\":\"Set last Assistant message as input\",\"type\":\"n8n-nodes-base.set\",\"position\":[-560,-3180],\"parameters\":{\"options\":{},\"assignments\":{\"assignments\":[{\"id\":\"38aa959a-e1e5-4c84-a7bd-ff5e0f61b62d\",\"name\":\"=chatInput\",\"type\":\"string\",\"value\":\"={{ $('Set lastAssistantMessage').first().json.lastAssistantMessage }}\"}]}},\"typeVersion\":3.4},{\"id\":\"7b389b9f-1751-4bc1-9c6f-bf6a04a1e09f\",\"name\":\"Set user message as input\",\"type\":\"n8n-nodes-base.set\",\"position\":[-560,-3380],\"parameters\":{\"options\":{},\"assignments\":{\"assignments\":[{\"id\":\"75b61275-7526-4431-b624-f8e098aa812d\",\"name\":\"chatInput\",\"type\":\"string\",\"value\":\"={{ $('When chat message received').item.json.chatInput }}\"}]}},\"typeVersion\":3.4},{\"id\":\"a238817f-0d10-4cd4-9760-53f69bb179f7\",\"name\":\"First loop?\",\"type\":\"n8n-nodes-base.if\",\"position\":[-780,-3280],\"parameters\":{\"options\":{},\"conditions\":{\"options\":{\"version\":2,\"leftValue\":\"\",\"caseSensitive\":true,\"typeValidation\":\"strict\"},\"combinator\":\"and\",\"conditions\":[{\"id\":\"51c41fdf-f4d3-4c7a-ac18-06815a59a958\",\"operator\":{\"type\":\"number\",\"operation\":\"equals\"},\"leftValue\":\"={{ $runIndex}}\",\"rightValue\":0}]}},\"typeVersion\":2.2},{\"id\":\"415927d7-b1a4-42b2-9607-c6ff707a528b\",\"name\":\"Set lastAssistantMessage\",\"type\":\"n8n-nodes-base.set\",\"position\":[36,-3155],\"parameters\":{\"options\":{},\"assignments\":{\"assignments\":[{\"id\":\"b93025b2-f5a7-476b-bd09-b5b4af050e73\",\"name\":\"lastAssistantMessage\",\"type\":\"string\",\"value\":\"=**{{ $('Loop Over Items').item.json.name }}**:\\n\\n{{ $json.output }}\"}]}},\"typeVersion\":3.4},{\"id\":\"77861e4b-a1d2-4c35-bf50-15914602a8b5\",\"name\":\"Combine and format responses\",\"type\":\"n8n-nodes-base.code\",\"position\":[-780,-3480],\"parameters\":{\"jsCode\":\"// Get the array of items from the input (output of the loop)\\nconst inputItems = items;\\n\\n// Extract the 'lastAssistantMessage' from each item's JSON data.\\n// If the field is missing or not a string, use an empty string to avoid errors.\\nconst messages = inputItems.map(item => {\\n  const message = item.json.lastAssistantMessage;\\n  return typeof message === 'string' ? message : '';\\n});\\n\\n// Join the extracted messages together with a horizontal rule separator\\nconst combinedText = messages.join('\\\\n\\\\n---\\\\n\\\\n');\\n\\n// Return a new single item containing the combined text.\\n// You can rename 'output' if you like.\\nreturn [{ json: { output: combinedText } }];\"},\"typeVersion\":2},{\"id\":\"4da2f95d-bce4-4844-a23c-63ca777efbfd\",\"name\":\"Define Global Settings\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1660,-3280],\"parameters\":{\"jsCode\":\"// Configure Global settings. This includes information about you - the user - and a section of the System Message that all Assistants will see. (Assistant-specific System Message sections can be set in the 'Define Agent Settings' node.)\\nreturn [\\n  {\\n    json: {\\n      \\\"user\\\": {\\n        \\\"name\\\": \\\"Jon\\\",\\n        \\\"location\\\": \\\"Melbourne, Australia\\\",\\n        \\\"notes\\\": \\\"Jon likes a casual, informal conversation style.\\\"\\n      },\\n      \\\"global\\\": {\\n        \\\"systemMessage\\\": \\\"Don't overdo the helpful, agreeable approach.\\\"\\n      }\\n    }\\n  }\\n];\\n\"},\"typeVersion\":2},{\"id\":\"6639a554-9e5f-40ac-b68e-b8eaa777252d\",\"name\":\"Define Agent Settings\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1440,-3280],\"parameters\":{\"jsCode\":\"// Configure Assistants. The number of Assistants can be changed by adding or removing JSON objects. Use the OpenRouter model naming convention.\\nreturn [\\n  {\\n    json: {\\n      \\\"Chad\\\": {\\n        \\\"name\\\": \\\"Chad\\\",\\n        \\\"model\\\": \\\"openai/gpt-4o\\\",\\n        \\\"systemMessage\\\": \\\"You are a helpful Assistant. You are eccentric and creative, and try to take discussions into unexpected territory.\\\"\\n      },\\n      \\\"Claude\\\": {\\n        \\\"name\\\": \\\"Claude\\\",\\n        \\\"model\\\": \\\"anthropic/claude-3.7-sonnet\\\",\\n        \\\"systemMessage\\\": \\\"You are logical and practical.\\\"\\n      },\\n      \\\"Gemma\\\": {\\n        \\\"name\\\": \\\"Gemma\\\",\\n        \\\"model\\\": \\\"google/gemini-2.0-flash-lite-001\\\",\\n        \\\"systemMessage\\\": \\\"You are super friendly and love to debate.\\\"\\n      }\\n    }\\n  }\\n];\\n\"},\"typeVersion\":2},{\"id\":\"d55a7e02-3574-4d78-a141-db8d3657857b\",\"name\":\"Sticky Note\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-1750,-3620],\"parameters\":{\"color\":4,\"width\":500,\"height\":500,\"content\":\"## Step 1: Configure Settings Nodes\\n\\nEdit the JSON in these nodes to:\\n\\n- Configure details about you (the user)\\n- Define content that will appear in all system messages\\n- Define Agents.\\n\\nFor Agents, you can configure:\\n- How many you create\\n- Their names\\n- The LLM model they use (choose any that are available via OpenRouter)\\n- Agent-specific system prompt content\"},\"typeVersion\":1},{\"id\":\"d3eb2797-4008-4bdb-a588-b2412ed5ffa7\",\"name\":\"Sticky Note1\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-400,-3620],\"parameters\":{\"color\":4,\"width\":360,\"height\":720,\"content\":\"## Step 2: Connect Agent to OpenRouter\\n\\nSet your OpenRouter credentials, and all other parameters including system messages and model selection are dynamically populated.\"},\"typeVersion\":1},{\"id\":\"a6085a55-db36-42d8-8c57-c9123490581f\",\"name\":\"Sticky Note2\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-1940,-3900],\"parameters\":{\"color\":5,\"width\":2180,\"height\":1100,\"content\":\"# Scalable Multi-Agent Conversations\\n\\n\"},\"typeVersion\":1},{\"id\":\"d2ee6317-3a9c-4df8-8fce-87daa3530233\",\"name\":\"Sticky Note3\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-1200,-3860],\"parameters\":{\"width\":380,\"height\":360,\"content\":\"## About this workflow\\n\\n**What does this workflow do?**\\nEnables you to initiate a conversation with multiple AI agents at once. Each agent can be configured with a unique name, system instructions, a different model.\\n\\n**How do I use it?**\\n1. Configure the settings nodes to create the Agents you need.\\n2. Call one or more individual agents using @Name mentions in your messages. If your message does not have @mentions, all agents will be called, in random order.\"},\"typeVersion\":1},{\"id\":\"a190a268-7f90-4c4e-aceb-482545d0b72b\",\"name\":\"Sticky Note4\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-820,-3860],\"parameters\":{\"width\":380,\"height\":360,\"content\":\"**How does it work?**\\nSettings are configured in the first two nodes after the chat trigger. Then @mentions in your message are extracted and fed into a loop. With each loop, the agent's system message and model are dynamically populated, avoiding the need to create multiple agent nodes and complex routing logic.\\n\\nWhen all agents have had their say, their responses are combined and formatted. The use of a shared memory node enables multi-round conversations.\\n\\n**What are the limitations?**\\nAgents cannot call each other or respond in parallel. Agents' responses are not visible to the user until all agents have responded.\\n\\n\"},\"typeVersion\":1},{\"id\":\"30d8c207-9a7a-46c5-be89-0deafc6c183f\",\"name\":\"OpenRouter Chat Model\",\"type\":\"@n8n/n8n-nodes-langchain.lmChatOpenRouter\",\"position\":[-312,-3060],\"parameters\":{\"model\":\"={{ $('Extract mentions').item.json.model }}\",\"options\":{}},\"credentials\":{\"openRouterApi\":{\"id\":\"jB56IT6KRdHSBbkw\",\"name\":\"OpenRouter account\"}},\"typeVersion\":1}],\"active\":false,\"pinData\":{},\"settings\":{\"executionOrder\":\"v1\"},\"versionId\":\"6c0312e7-7a81-41cd-9403-8ad947100b80\",\"connections\":{\"AI Agent\":{\"main\":[[{\"node\":\"Set lastAssistantMessage\",\"type\":\"main\",\"index\":0}]]},\"First loop?\":{\"main\":[[{\"node\":\"Set user message as input\",\"type\":\"main\",\"index\":0}],[{\"node\":\"Set last Assistant message as input\",\"type\":\"main\",\"index\":0}]]},\"Simple Memory\":{\"ai_memory\":[[{\"node\":\"AI Agent\",\"type\":\"ai_memory\",\"index\":0}]]},\"Loop Over Items\":{\"main\":[[{\"node\":\"Combine and format responses\",\"type\":\"main\",\"index\":0}],[{\"node\":\"First loop?\",\"type\":\"main\",\"index\":0}]]},\"Extract mentions\":{\"main\":[[{\"node\":\"Loop Over Items\",\"type\":\"main\",\"index\":0}]]},\"Define Agent Settings\":{\"main\":[[{\"node\":\"Extract mentions\",\"type\":\"main\",\"index\":0}]]},\"OpenRouter Chat Model\":{\"ai_languageModel\":[[{\"node\":\"AI Agent\",\"type\":\"ai_languageModel\",\"index\":0}]]},\"Define Global Settings\":{\"main\":[[{\"node\":\"Define Agent Settings\",\"type\":\"main\",\"index\":0}]]},\"Set lastAssistantMessage\":{\"main\":[[{\"node\":\"Loop Over Items\",\"type\":\"main\",\"index\":0}]]},\"Set user message as input\":{\"main\":[[{\"node\":\"AI Agent\",\"type\":\"main\",\"index\":0}]]},\"When chat message received\":{\"main\":[[{\"node\":\"Define Global Settings\",\"type\":\"main\",\"index\":0}]]},\"Combine and format responses\":{\"main\":[[]]},\"Set last Assistant message as input\":{\"main\":[[{\"node\":\"AI Agent\",\"type\":\"main\",\"index\":0}]]}}}",
  "readme": "### Summary\n\nEngage multiple, uniquely configured AI agents (using different models via OpenRouter) in a single conversation. Trigger specific agents with @mentions or let them all respond. Easily scalable by editing simple JSON settings.\n\n### Overview\n\nThis workflow is for users who want to experiment with or utilize multiple AI agents with distinct personalities, instructions, and underlying models within a single chat interface, without complex setup. It solves the problem of managing and interacting with diverse AI assistants simultaneously for tasks like brainstorming, comparative analysis, or role-playing scenarios.\n\nIt enables dynamic conversations with multiple AI assistants simultaneously within a single chat interface. You can:\n\n  * Define multiple unique AI agents.\n  * Configure each agent with its own name, system instructions, and LLM model (via OpenRouter).\n  * Interact with specific agents using `@AgentName` mentions.\n  * Have all agents respond (in random order) if no specific agents are mentioned.\n  * Maintain conversation history across multiple turns.\n\n\n\nIt's designed for flexibility and scalability, allowing you to easily add or modify agents without complex workflow restructuring.\n\n### Key Features\n\n  * **Multi-Agent Interaction:** Chat with several distinct AI personalities at once.\n  * **Individual Agent Configuration:** Customize name, system prompt, and LLM for each agent.\n  * **OpenRouter Integration:** Access a wide variety of LLMs compatible with OpenRouter.\n  * **Mention-Based Triggering:** Direct messages to specific agents using `@AgentName`.\n  * **All-Agent Fallback:** Engages all defined agents randomly if no mentions are used.\n  * **Scalable Setup:** Agent configuration is centralized in a single Code node (as JSON).\n  * **Conversation Memory:** Remembers previous interactions within the session.\n\n\n\n### How to Set Up\n\n  1. **Configure Settings (Code Nodes):**\n     * Open the `Define Global Settings` Code node: Edit the JSON to set user details (name, location, notes) and add any system message instructions that _all_ agents should follow.\n     * Open the `Define Agent Settings` Code node: Edit the JSON to define your agents. Add or remove agent objects as needed. For each agent, specify: \n       * `\"name\"`: The unique name for the agent (used for @mentions).\n       * `\"model\"`: The OpenRouter model identifier (e.g., `\"openai/gpt-4o\"`, `\"anthropic/claude-3.7-sonnet\"`).\n       * `\"systemMessage\"`: Specific instructions or persona for _this_ agent.\n  2. **Add OpenRouter Credentials:**\n     * Locate the `AI Agent` node.\n     * Click the `OpenRouter Chat Model` node connected below it via the `Language Model` input.\n     * In the 'Credential for OpenRouter API' field, select or create your OpenRouter API credentials.\n\n\n\n### How to Use\n\n  1. Start a conversation using the Chat Trigger input.\n  2. To address specific agents, include `@AgentName` in your message. Agents will respond sequentially in the order they are mentioned. \n     * _Example:_ `\"@Gemma @Claude, please continue the count: 1\"` will trigger Gemma first, followed by Claude.\n  3. If your message contains no `@mentions`, _all_ agents defined in `Define Agent Settings` will respond in a randomized order. \n     * _Example:_ `\"What are your thoughts on the future of AI?\"` will trigger Chad, Claude, and Gemma (based on your default settings) in a random sequence.\n  4. The workflow will collect responses from all triggered agents and return them as a single, formatted message.\n\n\n\n### How It Works (Technical Details)\n\n  1. **Settings Nodes:** `Define Global Settings` and `Define Agent Settings` load your configurations.\n  2. **Mention Extraction:** The `Extract mentions` Code node parses the user's input (`chatInput`) from the `When chat message received` trigger. It looks for `@AgentName` patterns matching the names defined in `Define Agent Settings`.\n  3. **Agent Selection:**\n     * If mentions are found, it creates a list of the corresponding agent configurations in the order they were mentioned.\n     * If no mentions are found, it creates a list of _all_ defined agent configurations and shuffles them randomly.\n  4. **Looping:** The `Loop Over Items` node iterates through the selected agent list.\n  5. **Dynamic Agent Execution:** Inside the loop: \n     * An `If` node (`First loop?`) checks if it's the first agent responding. If yes (`true` path -> `Set user message as input`), it passes the original user message to the Agent. If no (`false` path -> `Set last Assistant message as input`), it passes the _previous_ agent's formatted output (`lastAssistantMessage`) to the _next_ agent, creating a sequential chain.\n     * The `AI Agent` node receives the input message. Its `System Message` and the `Model` in the connected `OpenRouter Chat Model` node are dynamically populated using expressions referencing the current agent's data from the loop (`{{ $('Loop Over Items').item.json.* }}`).\n     * The `Simple Memory` node provides conversation history to the `AI Agent`.\n     * The agent's response is formatted (e.g., `**AgentName**:\\n\\nResponse`) in the `Set lastAssistantMessage` node.\n  6. **Response Aggregation:** After the loop finishes, the `Combine and format responses` Code node gathers all the `lastAssistantMessage` outputs and joins them into a single text block, separated by horizontal rules (`---`), ready to be sent back to the user.\n\n\n\n### Benefits\n\n  * **Scalability & Flexibility:** Instead of complex branching logic, adding, removing, or modifying agents only requires editing simple JSON in the `Define Agent Settings` node, making setup and maintenance significantly easier, especially for those managing multiple assistants.\n  * **Model Choice:** Use the best model for each agent's specific task or persona via OpenRouter.\n  * **Centralized Configuration:** Keeps agent setup tidy and manageable.\n\n\n\n### Limitations\n\n  * **Sequential Responses:** Agents respond one after another based on mention order (or randomly), not in parallel.\n  * **No Direct Agent-to-Agent Interaction (within a turn):** Agents cannot directly call or reply to each other _during_ the processing of a single user message. Agent B sees Agent A's response only because the workflow passes it as input in the next loop iteration.\n  * **Delayed Output:** The user receives the combined response only _after_ all triggered agents have completed their generation.\n\n\n",
  "readme_html": "<!--[--><div data-v-50766329=\"\"><h3>Summary</h3>\n<p>Engage multiple, uniquely configured AI agents (using different models via OpenRouter) in a single conversation. Trigger specific agents with @mentions or let them all respond. Easily scalable by editing simple JSON settings.</p>\n<h3>Overview</h3>\n<p>This workflow is for users who want to experiment with or utilize multiple AI agents with distinct personalities, instructions, and underlying models within a single chat interface, without complex setup. It solves the problem of managing and interacting with diverse AI assistants simultaneously for tasks like brainstorming, comparative analysis, or role-playing scenarios.</p>\n<p>It enables dynamic conversations with multiple AI assistants simultaneously within a single chat interface. You can:</p>\n<ul>\n<li>Define multiple unique AI agents.</li>\n<li>Configure each agent with its own name, system instructions, and LLM model (via OpenRouter).</li>\n<li>Interact with specific agents using <code>@AgentName</code> mentions.</li>\n<li>Have all agents respond (in random order) if no specific agents are mentioned.</li>\n<li>Maintain conversation history across multiple turns.</li>\n</ul>\n<p>It's designed for flexibility and scalability, allowing you to easily add or modify agents without complex workflow restructuring.</p>\n<h3>Key Features</h3>\n<ul>\n<li><strong>Multi-Agent Interaction:</strong> Chat with several distinct AI personalities at once.</li>\n<li><strong>Individual Agent Configuration:</strong> Customize name, system prompt, and LLM for each agent.</li>\n<li><strong>OpenRouter Integration:</strong> Access a wide variety of LLMs compatible with OpenRouter.</li>\n<li><strong>Mention-Based Triggering:</strong> Direct messages to specific agents using <code>@AgentName</code>.</li>\n<li><strong>All-Agent Fallback:</strong> Engages all defined agents randomly if no mentions are used.</li>\n<li><strong>Scalable Setup:</strong> Agent configuration is centralized in a single Code node (as JSON).</li>\n<li><strong>Conversation Memory:</strong> Remembers previous interactions within the session.</li>\n</ul>\n<h3>How to Set Up</h3>\n<ol>\n<li><strong>Configure Settings (Code Nodes):</strong>\n<ul>\n<li>Open the <code>Define Global Settings</code> Code node: Edit the JSON to set user details (name, location, notes) and add any system message instructions that <em>all</em> agents should follow.</li>\n<li>Open the <code>Define Agent Settings</code> Code node: Edit the JSON to define your agents. Add or remove agent objects as needed. For each agent, specify:\n<ul>\n<li><code>\"name\"</code>: The unique name for the agent (used for @mentions).</li>\n<li><code>\"model\"</code>: The OpenRouter model identifier (e.g., <code>\"openai/gpt-4o\"</code>, <code>\"anthropic/claude-3.7-sonnet\"</code>).</li>\n<li><code>\"systemMessage\"</code>: Specific instructions or persona for <em>this</em> agent.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Add OpenRouter Credentials:</strong>\n<ul>\n<li>Locate the <code>AI Agent</code> node.</li>\n<li>Click the <code>OpenRouter Chat Model</code> node connected below it via the <code>Language Model</code> input.</li>\n<li>In the 'Credential for OpenRouter API' field, select or create your OpenRouter API credentials.</li>\n</ul>\n</li>\n</ol>\n<h3>How to Use</h3>\n<ol>\n<li>Start a conversation using the Chat Trigger input.</li>\n<li>To address specific agents, include <code>@AgentName</code> in your message. Agents will respond sequentially in the order they are mentioned.\n<ul>\n<li><em>Example:</em> <code>\"@Gemma @Claude, please continue the count: 1\"</code> will trigger Gemma first, followed by Claude.</li>\n</ul>\n</li>\n<li>If your message contains no <code>@mentions</code>, <em>all</em> agents defined in <code>Define Agent Settings</code> will respond in a randomized order.\n<ul>\n<li><em>Example:</em> <code>\"What are your thoughts on the future of AI?\"</code> will trigger Chad, Claude, and Gemma (based on your default settings) in a random sequence.</li>\n</ul>\n</li>\n<li>The workflow will collect responses from all triggered agents and return them as a single, formatted message.</li>\n</ol>\n<h3>How It Works (Technical Details)</h3>\n<ol>\n<li><strong>Settings Nodes:</strong> <code>Define Global Settings</code> and <code>Define Agent Settings</code> load your configurations.</li>\n<li><strong>Mention Extraction:</strong> The <code>Extract mentions</code> Code node parses the user's input (<code>chatInput</code>) from the <code>When chat message received</code> trigger. It looks for <code>@AgentName</code> patterns matching the names defined in <code>Define Agent Settings</code>.</li>\n<li><strong>Agent Selection:</strong>\n<ul>\n<li>If mentions are found, it creates a list of the corresponding agent configurations in the order they were mentioned.</li>\n<li>If no mentions are found, it creates a list of <em>all</em> defined agent configurations and shuffles them randomly.</li>\n</ul>\n</li>\n<li><strong>Looping:</strong> The <code>Loop Over Items</code> node iterates through the selected agent list.</li>\n<li><strong>Dynamic Agent Execution:</strong> Inside the loop:\n<ul>\n<li>An <code>If</code> node (<code>First loop?</code>) checks if it's the first agent responding. If yes (<code>true</code> path -&gt; <code>Set user message as input</code>), it passes the original user message to the Agent. If no (<code>false</code> path -&gt; <code>Set last Assistant message as input</code>), it passes the <em>previous</em> agent's formatted output (<code>lastAssistantMessage</code>) to the <em>next</em> agent, creating a sequential chain.</li>\n<li>The <code>AI Agent</code> node receives the input message. Its <code>System Message</code> and the <code>Model</code> in the connected <code>OpenRouter Chat Model</code> node are dynamically populated using expressions referencing the current agent's data from the loop (<code>{{ $('Loop Over Items').item.json.* }}</code>).</li>\n<li>The <code>Simple Memory</code> node provides conversation history to the <code>AI Agent</code>.</li>\n<li>The agent's response is formatted (e.g., <code>**AgentName**:\\n\\nResponse</code>) in the <code>Set lastAssistantMessage</code> node.</li>\n</ul>\n</li>\n<li><strong>Response Aggregation:</strong> After the loop finishes, the <code>Combine and format responses</code> Code node gathers all the <code>lastAssistantMessage</code> outputs and joins them into a single text block, separated by horizontal rules (<code>---</code>), ready to be sent back to the user.</li>\n</ol>\n<h3>Benefits</h3>\n<ul>\n<li><strong>Scalability &amp; Flexibility:</strong> Instead of complex branching logic, adding, removing, or modifying agents only requires editing simple JSON in the <code>Define Agent Settings</code> node, making setup and maintenance significantly easier, especially for those managing multiple assistants.</li>\n<li><strong>Model Choice:</strong> Use the best model for each agent's specific task or persona via OpenRouter.</li>\n<li><strong>Centralized Configuration:</strong> Keeps agent setup tidy and manageable.</li>\n</ul>\n<h3>Limitations</h3>\n<ul>\n<li><strong>Sequential Responses:</strong> Agents respond one after another based on mention order (or randomly), not in parallel.</li>\n<li><strong>No Direct Agent-to-Agent Interaction (within a turn):</strong> Agents cannot directly call or reply to each other <em>during</em> the processing of a single user message. Agent B sees Agent A's response only because the workflow passes it as input in the next loop iteration.</li>\n<li><strong>Delayed Output:</strong> The user receives the combined response only <em>after</em> all triggered agents have completed their generation.</li>\n</ul>\n</div><!--]-->",
  "readme_zh": "### 概述\n\n本工作流专为希望在同一聊天界面中实验或使用多个具有不同个性、指令和底层模型的AI代理的用户设计，无需复杂设置。它解决了同时管理和交互多样化AI助手的问题，适用于头脑风暴、对比分析或角色扮演等场景。\n\n通过该工作流，您可以在单一聊天界面中实现与多个AI助手的动态对话：\n- 定义多个独特的AI代理\n- 为每个代理配置专属名称、系统指令和LLM模型（通过OpenRouter）\n- 使用`@代理名`提及特定代理进行交互\n- 未提及特定代理时，所有代理将随机顺序响应\n- 支持跨多轮对话的上下文记忆\n\n采用灵活可扩展的设计，无需复杂重构即可轻松添加或修改代理。\n\n### 核心功能\n\n* **多代理交互**：同时与多个不同个性的AI对话\n* **独立代理配置**：自定义每个代理的名称、系统提示和LLM模型\n* **OpenRouter集成**：支持所有OpenRouter兼容的LLM模型\n* **提及触发机制**：通过`@代理名`定向呼叫特定代理\n* **全员响应模式**：未使用提及时所有代理随机响应\n* **可扩展架构**：通过单一代码节点（JSON格式）集中管理代理配置\n* **对话记忆**：保持会话期间的交互历史\n\n### 配置指南\n\n1. **参数设置（代码节点）**：\n   - 打开`全局设置`代码节点：编辑JSON设置用户信息（姓名/位置/备注）及所有代理共享的系统指令\n   - 打开`代理设置`代码节点：编辑JSON定义代理。每个代理需指定：\n     - `\"name\"`：用于提及呼叫的唯一名称\n     - `\"model\"`：OpenRouter模型标识符（如`\"openai/gpt-4o\"`）\n     - `\"systemMessage\"`：该代理的专属指令或角色设定\n\n2. **添加OpenRouter凭证**：\n   - 定位`AI代理`节点\n   - 点击其下方通过`语言模型`接口连接的`OpenRouter聊天模型`节点\n   - 在\"OpenRouter API凭证\"字段选择或创建API凭证\n\n### 使用说明\n\n1. 通过聊天触发器开始对话\n2. 呼叫特定代理时在消息中包含`@代理名`，代理将按提及顺序响应\n   - *示例*：`\"@Gemma @Claude，请接龙计数：1\"`会先触发Gemma，再触发Claude\n3. 未使用提及时，`代理设置`中定义的所有代理将随机顺序响应\n   - *示例*：`\"你们对AI未来有何看法？\"`会随机触发Chad、Claude和Gemma（基于默认设置）\n4. 工作流将收集所有触发代理的响应，并返回格式化后的组合消息\n\n### 技术原理\n\n1. **设置节点**：加载`全局设置`和`代理设置`的配置\n2. **提及提取**：解析聊天触发器输入，匹配`代理设置`中定义的`@代理名`模式\n3. **代理选择**：\n   - 检测到提及时，按提及顺序创建代理配置列表\n   - 未检测提及时，随机打乱所有代理配置\n4. **循环处理**：通过`循环项`节点遍历选定代理列表\n5. **动态执行**：\n   - 首轮循环使用用户原始输入，后续轮次使用上一代理的格式化输出\n   - `AI代理`节点的系统消息和模型参数通过循环项动态注入\n   - `简易记忆`节点提供对话历史记录\n   - 代理响应按`**代理名**:\\n\\n响应`格式处理\n6. **响应聚合**：所有代理响应通过水平分隔线（`---`）组合后返回用户\n\n### 优势\n\n* **灵活扩展**：仅需编辑JSON即可增删改代理，显著降低多助手管理复杂度\n* **模型择优**：通过OpenRouter为每个代理选择最适合任务的模型\n* **配置集中**：保持代理设置整洁有序\n\n### 限制\n\n* **串行响应**：代理按提及顺序（或随机）依次响应，非并行处理\n* **代理间无直接交互**：单个消息处理周期内，代理无法直接相互调用（后序代理通过工作流接收前序输出）\n* **延迟输出**：用户需等待所有触发代理完成生成后才能获取组合响应",
  "title_zh": "可扩展的多智能体聊天系统（通过@提及实现）",
  "publish_date_zh": "上次更新于一个月前",
  "workflow_json_zh": "{\n  \"id\": \"0QQxgdQABUbbDJ0G\",\n  \"meta\": {\n    \"instanceId\": \"c98909b50b05c4069bd93ee5a4753d07322c9680e81da8568e96de2c713adb5c\"\n  },\n  \"name\": \"Multi-Agent Conversation\",\n  \"tags\": [],\n  \"nodes\": [\n    {\n      \"id\": \"218308e2-dc68-43ee-ae84-d931ad7a4ac5\",\n      \"name\": \"When chat message received\",\n      \"type\": \"@n8n/n8n-nodes-langchain.chatTrigger\",\n      \"position\": [\n        -1880,\n        -3280\n      ],\n      \"webhookId\": \"a74752f3-419a-4510-856f-3efeaceec019\",\n      \"parameters\": {\n        \"options\": {}\n      },\n      \"typeVersion\": 1.1\n    },\n    {\n      \"id\": \"a519fe1e-8739-46e0-9770-deb256ab96cf\",\n      \"name\": \"AI Agent\",\n      \"type\": \"@n8n/n8n-nodes-langchain.agent\",\n      \"position\": [\n        -340,\n        -3280\n      ],\n      \"parameters\": {\n        \"text\": \"={{ $json.chatInput }}\",\n        \"options\": {\n          \"systemMessage\": \"=Current date is {{ $now.format('yyyy-MM-dd') }}. The current time is {{ $now.format('HH:MM:ss') }}.\\n\\nThe user is {{ $('Define Global Settings').item.json.user.name }}, based in {{ $('Define Global Settings').item.json.user.location }}. {{ $('Define Global Settings').item.json.user.notes }}\\n\\nYou are part of a conversation with a user and multiple AI Assistants: {{ $('Define Agent Settings').item.json.keys() }}\\n\\nYou are {{ $('First loop?').item.json.name }}.\\n\\n{{ $('Loop Over Items').item.json.systemMessage }}\\n\\n{{ $('Define Global Settings').item.json.global.systemMessage }}\"\n        },\n        \"promptType\": \"define\"\n      },\n      \"typeVersion\": 1.8\n    },\n    {\n      \"id\": \"2e00f0ff-e7af-45d5-99bc-23031b5d7892\",\n      \"name\": \"Loop Over Items\",\n      \"type\": \"n8n-nodes-base.splitInBatches\",\n      \"position\": [\n        -1000,\n        -3280\n      ],\n      \"parameters\": {\n        \"options\": {}\n      },\n      \"typeVersion\": 3\n    },\n    {\n      \"id\": \"1c979a20-46a5-4591-92da-82c1c96277c6\",\n      \"name\": \"Extract mentions\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1220,\n        -3280\n      ],\n      \"parameters\": {\n        \"jsCode\": \"// Analyzes the user message and extracts @mentions in the order they appear. If there are none, all Assistants will be called in random order.\\n// --- Configuration: Adjust these lines ---\\nconst chatMessageNodeName = 'When chat message received'; // <-- Replace with your Chat Message node name\\nconst agentSetupNodeName = 'Define Agent Settings';         // <-- Replace with your Agent Setup node name\\nconst chatTextPath = 'json.chatInput';               // <-- Replace with path to text in Chat node output (e.g., 'json.message')\\n// --- End Configuration ---\\n\\n// Helper function for safe nested property access (alternative to _.get)\\nfunction getSafe(obj, path, defaultValue = undefined) {\\n    const pathParts = path.split('.');\\n    let current = obj;\\n    for (const part of pathParts) {\\n        if (current === null || current === undefined || typeof current !== 'object' || !Object.prototype.hasOwnProperty.call(current, part)) {\\n            return defaultValue;\\n        }\\n        current = current[part];\\n    }\\n    return current ?? defaultValue;\\n}\\n\\n// 1. Get Chat Text\\nconst chatMessageNode = $(chatMessageNodeName);\\nconst chatText = getSafe(chatMessageNode.item, chatTextPath, '');\\n\\n// 2. Get Agent Data and Names\\nconst agentSetupNode = $(agentSetupNodeName);\\nconst agentData = getSafe(agentSetupNode.item, 'json', {}); // e.g., { Chad: {...}, Gemma: {...}, Claude: {...} }\\nconst agentNames = Object.keys(agentData);\\n\\n// 3. Find all mentions, their names, and their positions in the text\\nconst foundMentions = [];\\nif (chatText && agentNames.length > 0) {\\n    const escapeRegex = (s) => s.replace(/[-\\\\/\\\\\\\\^$*+?.()|[\\\\]{}]/g, '\\\\\\\\$&');\\n    const agentPatternPart = agentNames.map(escapeRegex).join('|');\\n\\n    if (agentPatternPart) {\\n        const mentionPattern = new RegExp(`\\\\\\\\B@(${agentPatternPart})\\\\\\\\b`, 'gi');\\n        const matches = chatText.matchAll(mentionPattern);\\n\\n        for (const match of matches) {\\n            const matchedNameCaseInsensitive = match[1];\\n            const matchIndex = match.index;\\n            const canonicalName = agentNames.find(name => name.toLowerCase() === matchedNameCaseInsensitive.toLowerCase());\\n            if (canonicalName) {\\n                foundMentions.push({ name: canonicalName, index: matchIndex });\\n            }\\n        }\\n    }\\n}\\n\\n// 4. Sort the found mentions by their index (order of appearance)\\nfoundMentions.sort((a, b) => a.index - b.index);\\n\\n// 5. Map the sorted mentions to the desired output format (array of agent detail objects)\\nlet outputArray = foundMentions.map(mention => {\\n    const agentDetails = agentData[mention.name];\\n    if (!agentDetails) {\\n        console.warn(`Could not find details for agent: ${mention.name}`);\\n        return null;\\n    }\\n    return {\\n        name: agentDetails.name,\\n        model: agentDetails.model,\\n        systemMessage: agentDetails.systemMessage\\n    };\\n}).filter(item => item !== null);\\n\\n// 6. Check if any mentions were specifically found. If not, populate outputArray with ALL agents in RANDOM order.\\nif (outputArray.length === 0 && foundMentions.length === 0) { // Check if NO mentions were found initially\\n    // --- NO MENTIONS FOUND ---\\n    // Populate outputArray with ALL agents from agentData\\n    const allAgentDetailsArray = Object.values(agentData);\\n\\n    // --- Simple Randomization ---\\n    // Shuffle the array in place using sort with a random comparator\\n    allAgentDetailsArray.sort(() => 0.5 - Math.random());\\n    // --- End Randomization ---\\n\\n    // Map all agents (now in random order) to the output structure\\n    outputArray = allAgentDetailsArray.map(agentObject => ({\\n        name: agentObject.name,\\n        model: agentObject.model,\\n        systemMessage: agentObject.systemMessage\\n    }));\\n} // Intentionally no 'else' here, if outputArray already had items from mentions, we use that.\\n\\n// 7. Final Output Formatting (Handles both cases: specific mentions OR all agents)\\n// Check if, after everything, the outputArray is *still* empty (e.g., if agentData was empty initially)\\nif (outputArray.length === 0) {\\n    // If still empty, return a status or error as a fallback\\n     return [{ json: { status: \\\"no_agents_available\\\", message: \\\"No mentions found and no agents defined.\\\" } }];\\n} else {\\n    // Return the array of agent objects formatted for n8n (multiple items)\\n    return outputArray.map(agentObject => ({ json: agentObject }));\\n}\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"45f635ca-f4fa-4f6c-a32a-9722906255fd\",\n      \"name\": \"Simple Memory\",\n      \"type\": \"@n8n/n8n-nodes-langchain.memoryBufferWindow\",\n      \"position\": [\n        -192,\n        -3060\n      ],\n      \"parameters\": {\n        \"sessionKey\": \"={{ $('When chat message received').first().json.sessionId }}\",\n        \"sessionIdType\": \"customKey\",\n        \"contextWindowLength\": 99\n      },\n      \"typeVersion\": 1.3\n    },\n    {\n      \"id\": \"5c903044-bce2-4aa8-b168-a460a4999c54\",\n      \"name\": \"Set last Assistant message as input\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"position\": [\n        -560,\n        -3180\n      ],\n      \"parameters\": {\n        \"options\": {},\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"38aa959a-e1e5-4c84-a7bd-ff5e0f61b62d\",\n              \"name\": \"=chatInput\",\n              \"type\": \"string\",\n              \"value\": \"={{ $('Set lastAssistantMessage').first().json.lastAssistantMessage }}\"\n            }\n          ]\n        }\n      },\n      \"typeVersion\": 3.4\n    },\n    {\n      \"id\": \"7b389b9f-1751-4bc1-9c6f-bf6a04a1e09f\",\n      \"name\": \"Set user message as input\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"position\": [\n        -560,\n        -3380\n      ],\n      \"parameters\": {\n        \"options\": {},\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"75b61275-7526-4431-b624-f8e098aa812d\",\n              \"name\": \"chatInput\",\n              \"type\": \"string\",\n              \"value\": \"={{ $('When chat message received').item.json.chatInput }}\"\n            }\n          ]\n        }\n      },\n      \"typeVersion\": 3.4\n    },\n    {\n      \"id\": \"a238817f-0d10-4cd4-9760-53f69bb179f7\",\n      \"name\": \"First loop?\",\n      \"type\": \"n8n-nodes-base.if\",\n      \"position\": [\n        -780,\n        -3280\n      ],\n      \"parameters\": {\n        \"options\": {},\n        \"conditions\": {\n          \"options\": {\n            \"version\": 2,\n            \"leftValue\": \"\",\n            \"caseSensitive\": true,\n            \"typeValidation\": \"strict\"\n          },\n          \"combinator\": \"and\",\n          \"conditions\": [\n            {\n              \"id\": \"51c41fdf-f4d3-4c7a-ac18-06815a59a958\",\n              \"operator\": {\n                \"type\": \"number\",\n                \"operation\": \"equals\"\n              },\n              \"leftValue\": \"={{ $runIndex}}\",\n              \"rightValue\": 0\n            }\n          ]\n        }\n      },\n      \"typeVersion\": 2.2\n    },\n    {\n      \"id\": \"415927d7-b1a4-42b2-9607-c6ff707a528b\",\n      \"name\": \"Set lastAssistantMessage\",\n      \"type\": \"n8n-nodes-base.set\",\n      \"position\": [\n        36,\n        -3155\n      ],\n      \"parameters\": {\n        \"options\": {},\n        \"assignments\": {\n          \"assignments\": [\n            {\n              \"id\": \"b93025b2-f5a7-476b-bd09-b5b4af050e73\",\n              \"name\": \"lastAssistantMessage\",\n              \"type\": \"string\",\n              \"value\": \"=**{{ $('Loop Over Items').item.json.name }}**:\\n\\n{{ $json.output }}\"\n            }\n          ]\n        }\n      },\n      \"typeVersion\": 3.4\n    },\n    {\n      \"id\": \"77861e4b-a1d2-4c35-bf50-15914602a8b5\",\n      \"name\": \"Combine and format responses\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -780,\n        -3480\n      ],\n      \"parameters\": {\n        \"jsCode\": \"// Get the array of items from the input (output of the loop)\\nconst inputItems = items;\\n\\n// Extract the 'lastAssistantMessage' from each item's JSON data.\\n// If the field is missing or not a string, use an empty string to avoid errors.\\nconst messages = inputItems.map(item => {\\n  const message = item.json.lastAssistantMessage;\\n  return typeof message === 'string' ? message : '';\\n});\\n\\n// Join the extracted messages together with a horizontal rule separator\\nconst combinedText = messages.join('\\\\n\\\\n---\\\\n\\\\n');\\n\\n// Return a new single item containing the combined text.\\n// You can rename 'output' if you like.\\nreturn [{ json: { output: combinedText } }];\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"4da2f95d-bce4-4844-a23c-63ca777efbfd\",\n      \"name\": \"Define Global Settings\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1660,\n        -3280\n      ],\n      \"parameters\": {\n        \"jsCode\": \"// Configure Global settings. This includes information about you - the user - and a section of the System Message that all Assistants will see. (Assistant-specific System Message sections can be set in the 'Define Agent Settings' node.)\\nreturn [\\n  {\\n    json: {\\n      \\\"user\\\": {\\n        \\\"name\\\": \\\"Jon\\\",\\n        \\\"location\\\": \\\"Melbourne, Australia\\\",\\n        \\\"notes\\\": \\\"Jon likes a casual, informal conversation style.\\\"\\n      },\\n      \\\"global\\\": {\\n        \\\"systemMessage\\\": \\\"Don't overdo the helpful, agreeable approach.\\\"\\n      }\\n    }\\n  }\\n];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"6639a554-9e5f-40ac-b68e-b8eaa777252d\",\n      \"name\": \"Define Agent Settings\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1440,\n        -3280\n      ],\n      \"parameters\": {\n        \"jsCode\": \"// Configure Assistants. The number of Assistants can be changed by adding or removing JSON objects. Use the OpenRouter model naming convention.\\nreturn [\\n  {\\n    json: {\\n      \\\"Chad\\\": {\\n        \\\"name\\\": \\\"Chad\\\",\\n        \\\"model\\\": \\\"openai/gpt-4o\\\",\\n        \\\"systemMessage\\\": \\\"You are a helpful Assistant. You are eccentric and creative, and try to take discussions into unexpected territory.\\\"\\n      },\\n      \\\"Claude\\\": {\\n        \\\"name\\\": \\\"Claude\\\",\\n        \\\"model\\\": \\\"anthropic/claude-3.7-sonnet\\\",\\n        \\\"systemMessage\\\": \\\"You are logical and practical.\\\"\\n      },\\n      \\\"Gemma\\\": {\\n        \\\"name\\\": \\\"Gemma\\\",\\n        \\\"model\\\": \\\"google/gemini-2.0-flash-lite-001\\\",\\n        \\\"systemMessage\\\": \\\"You are super friendly and love to debate.\\\"\\n      }\\n    }\\n  }\\n];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"d55a7e02-3574-4d78-a141-db8d3657857b\",\n      \"name\": \"Sticky Note\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -1750,\n        -3620\n      ],\n      \"parameters\": {\n        \"color\": 4,\n        \"width\": 500,\n        \"height\": 500,\n        \"content\": \"## 第一步：配置设置节点\\n\\n编辑这些节点中的JSON以：\\n\\n- 配置关于您（用户）的详细信息\\n- 定义将出现在所有系统消息中的内容\\n- 设置智能体代理\\n\\n对于智能体代理，您可以配置：\\n- 创建的数量\\n- 代理名称\\n- 使用的LLM模型（可通过OpenRouter选择任何可用模型）\\n- 代理专属的系统提示内容\"\n      },\n      \"typeVersion\": 1\n    },\n    {\n      \"id\": \"d3eb2797-4008-4bdb-a588-b2412ed5ffa7\",\n      \"name\": \"Sticky Note1\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -400,\n        -3620\n      ],\n      \"parameters\": {\n        \"color\": 4,\n        \"width\": 360,\n        \"height\": 720,\n        \"content\": \"## 第二步：将代理连接至OpenRouter\\n\\n设置您的OpenRouter凭证后，包括系统消息和模型选择在内的所有其他参数都将动态填充。\"\n      },\n      \"typeVersion\": 1\n    },\n    {\n      \"id\": \"a6085a55-db36-42d8-8c57-c9123490581f\",\n      \"name\": \"Sticky Note2\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -1940,\n        -3900\n      ],\n      \"parameters\": {\n        \"color\": 5,\n        \"width\": 2180,\n        \"height\": 1100,\n        \"content\": \"# 可扩展的多智能体对话\"\n      },\n      \"typeVersion\": 1\n    },\n    {\n      \"id\": \"d2ee6317-3a9c-4df8-8fce-87daa3530233\",\n      \"name\": \"Sticky Note3\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -1200,\n        -3860\n      ],\n      \"parameters\": {\n        \"width\": 380,\n        \"height\": 360,\n        \"content\": \"## 关于此工作流\\n\\n**此工作流有何功能？**\\n允许您同时与多个AI智能体展开对话。每个智能体均可配置专属名称、系统指令及不同模型。\\n\\n**如何使用？**\\n1. 通过设置节点配置所需的智能体\\n2. 在消息中使用@名称提及来调用单个或多个智能体。若消息未包含@提及，将随机顺序调用全部智能体。\"\n      },\n      \"typeVersion\": 1\n    },\n    {\n      \"id\": \"a190a268-7f90-4c4e-aceb-482545d0b72b\",\n      \"name\": \"Sticky Note4\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -820,\n        -3860\n      ],\n      \"parameters\": {\n        \"width\": 380,\n        \"height\": 360,\n        \"content\": \"**它是如何工作的？**  \\n设置项配置在聊天触发器后的前两个节点中完成。随后，消息中的@提及会被提取并输入循环处理。每次循环时，智能体的系统消息和模型会动态填充，从而无需创建多个智能体节点和复杂的路由逻辑。  \\n\\n当所有智能体完成响应后，它们的回复会被合并并格式化。通过共享记忆节点的设计，实现了多轮对话功能。  \\n\\n**存在哪些限制？**  \\n智能体之间无法互相调用或并行响应。在所有智能体完成回复前，用户无法看到任何单个智能体的响应内容。\"\n      },\n      \"typeVersion\": 1\n    },\n    {\n      \"id\": \"30d8c207-9a7a-46c5-be89-0deafc6c183f\",\n      \"name\": \"OpenRouter Chat Model\",\n      \"type\": \"@n8n/n8n-nodes-langchain.lmChatOpenRouter\",\n      \"position\": [\n        -312,\n        -3060\n      ],\n      \"parameters\": {\n        \"model\": \"={{ $('Extract mentions').item.json.model }}\",\n        \"options\": {}\n      },\n      \"credentials\": {\n        \"openRouterApi\": {\n          \"id\": \"jB56IT6KRdHSBbkw\",\n          \"name\": \"OpenRouter account\"\n        }\n      },\n      \"typeVersion\": 1\n    }\n  ],\n  \"active\": false,\n  \"pinData\": {},\n  \"settings\": {\n    \"executionOrder\": \"v1\"\n  },\n  \"versionId\": \"6c0312e7-7a81-41cd-9403-8ad947100b80\",\n  \"connections\": {\n    \"AI Agent\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Set lastAssistantMessage\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"First loop?\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Set user message as input\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"Set last Assistant message as input\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Simple Memory\": {\n      \"ai_memory\": [\n        [\n          {\n            \"node\": \"AI Agent\",\n            \"type\": \"ai_memory\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Loop Over Items\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Combine and format responses\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"First loop?\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Extract mentions\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Loop Over Items\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Define Agent Settings\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Extract mentions\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"OpenRouter Chat Model\": {\n      \"ai_languageModel\": [\n        [\n          {\n            \"node\": \"AI Agent\",\n            \"type\": \"ai_languageModel\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Define Global Settings\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Define Agent Settings\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Set lastAssistantMessage\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Loop Over Items\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Set user message as input\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"AI Agent\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"When chat message received\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Define Global Settings\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Combine and format responses\": {\n      \"main\": [\n        []\n      ]\n    },\n    \"Set last Assistant message as input\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"AI Agent\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}"
}