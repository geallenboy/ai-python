{
  "title": "Create Secure Interactive Applications with WhatsApp Flows End-to-End Encryption",
  "url": "https://n8n.io/workflows/3973-create-secure-interactive-applications-with-whatsapp-flows-end-to-end-encryption/",
  "category": "Engineering",
  "category_url": "https://n8n.io/workflows/categories/engineering/?sort=createdAt:desc",
  "author": "Flavio Angeleu",
  "publish_date": "Last update a day ago",
  "publish_date_absolute": "",
  "content": "",
  "workflow_json": "{\"meta\":{\"instanceId\":\"32014bf2061907b54debfd6d86e0e8dc3f3ec9cdd9123c339fc7506178206d83\",\"templateCredsSetupCompleted\":true},\"nodes\":[{\"id\":\"1874c66a-97f0-4a33-a4e9-ab27b950edb4\",\"name\":\"Webhook1\",\"type\":\"n8n-nodes-base.webhook\",\"position\":[-1820,860],\"webhookId\":\"7116a2e3-c07f-4638-9140-3548a7957d15\",\"parameters\":{\"path\":\"flow\",\"options\":{\"responseHeaders\":{\"entries\":[{\"name\":\"Content-Type\",\"value\":\"text/plain\"}]}},\"httpMethod\":\"POST\",\"responseMode\":\"responseNode\"},\"typeVersion\":2},{\"id\":\"ae85225c-addf-44e8-a60f-f9e0f07a9bc0\",\"name\":\"Json Parser\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1060,860],\"parameters\":{\"jsCode\":\"function processPayload(items) {\\n  // Create a new array to store the processed items\\n  const processedItems = [];\\n  \\n  // Process each item in the input array\\n  for (const item of items) {\\n    try {\\n      // Extract the decryptedPayload string from the current item\\n      const decryptedPayloadString = item.json.decryptedPayload;\\n      \\n      // Parse the decryptedPayload string into a JavaScript object\\n      const decryptedPayloadObject = JSON.parse(decryptedPayloadString);\\n      \\n      // Extract the date from the data object\\n      const date = decryptedPayloadObject.data.date;\\n      \\n      // Extract the screen value\\n      const screen = decryptedPayloadObject.screen;\\n\\n      // Extract the flow_token object\\n      const flow_token = decryptedPayloadObject.flow_token;\\n      \\n      // Create a new item with the extracted date and screen\\n      const newItem = {\\n        json: {\\n          date: date,\\n          screen: screen,\\n          flow_token: flow_token,\\n          // Optionally preserve original data\\n          originalPayload: item.json\\n        }\\n      };\\n      \\n      // Add the processed item to our array\\n      processedItems.push(newItem);\\n    } catch (error) {\\n      // If there's an error, create an item with error information\\n      processedItems.push({\\n        json: {\\n          error: error.message,\\n          originalItem: item.json\\n        }\\n      });\\n    }\\n  }\\n  \\n  return processedItems;\\n}\\n\\nreturn processPayload(items);\"},\"typeVersion\":2},{\"id\":\"8ee86c97-ed4f-48d1-924f-4252e1c07aa5\",\"name\":\"Switch\",\"type\":\"n8n-nodes-base.switch\",\"position\":[-740,860],\"parameters\":{\"rules\":{\"values\":[{\"conditions\":{\"options\":{\"version\":2,\"leftValue\":\"\",\"caseSensitive\":true,\"typeValidation\":\"strict\"},\"combinator\":\"and\",\"conditions\":[{\"id\":\"aa929857-8458-49da-a027-0b4d4a7f75f7\",\"operator\":{\"type\":\"string\",\"operation\":\"equals\"},\"leftValue\":\"={{ $json.screen }}\",\"rightValue\":\"APPOINTMENT\"}]}},{\"conditions\":{\"options\":{\"version\":2,\"leftValue\":\"\",\"caseSensitive\":true,\"typeValidation\":\"strict\"},\"combinator\":\"and\",\"conditions\":[{\"id\":\"d83dd890-5ee5-480e-b338-efc5eb26b494\",\"operator\":{\"name\":\"filter.operator.equals\",\"type\":\"string\",\"operation\":\"equals\"},\"leftValue\":\"={{ $json.screen }}\",\"rightValue\":\"DATE_SELECTION_SCREEN\"}]}}]},\"options\":{}},\"typeVersion\":3.2},{\"id\":\"76fad406-2591-4531-acab-01cbfcf41c3f\",\"name\":\"Respond to Webhook1\",\"type\":\"n8n-nodes-base.respondToWebhook\",\"position\":[40,760],\"parameters\":{\"options\":{\"responseCode\":200},\"respondWith\":\"text\",\"responseBody\":\"={{ $json.body }}\"},\"typeVersion\":1.1},{\"id\":\"56cb338a-9d7a-4f1a-9c55-5ca9db4f3560\",\"name\":\"Data Extraction Code\",\"type\":\"n8n-nodes-base.code\",\"position\":[-400,760],\"parameters\":{\"jsCode\":\"const groupedAppointments = items.reduce((acc, { json: { appointment_date, start_time } }) => {\\n  const dateKey = new Date(appointment_date).toISOString().split('T')[0];\\n  if (!acc[dateKey]) {\\n    acc[dateKey] = [];\\n  }\\n  acc[dateKey].push(start_time);\\n  return acc;\\n}, {});\\n\\nreturn Object.entries(groupedAppointments).map(([date, times]) => ({\\n  json: { appointment_date: date, start_times: times }\\n}));\\n\"},\"typeVersion\":2},{\"id\":\"8bd15faf-3a9b-4bb4-ac83-c913a7373480\",\"name\":\"Respond to Webhook2\",\"type\":\"n8n-nodes-base.respondToWebhook\",\"position\":[40,1000],\"parameters\":{\"options\":{\"responseCode\":200},\"respondWith\":\"text\",\"responseBody\":\"={{ $json.body }}\"},\"typeVersion\":1.1},{\"id\":\"67b06ae5-81c1-4efd-993e-a54e36bc5ce7\",\"name\":\"Data Extraction Code1\",\"type\":\"n8n-nodes-base.code\",\"position\":[-400,1000],\"parameters\":{\"jsCode\":\"const jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\n// Return the result properly formatted for n8n\\nreturn seats.map(seat => ({ json: { seat } }));\\n\"},\"typeVersion\":2},{\"id\":\"2d05f87c-a2c5-4790-9a85-c6cda46db927\",\"name\":\"move to base64\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1600,860],\"parameters\":{\"jsCode\":\"console.log($json);\\n\\nreturn [\\n  {\\n    encryptedFlowData: Buffer.from($json.body?.encrypted_flow_data || \\\"\\\", \\\"base64\\\"),\\n    encryptedAesKey: Buffer.from($json.body?.encrypted_aes_key || \\\"\\\", \\\"base64\\\"),\\n    initialVector: Buffer.from($json.body?.initial_vector || \\\"\\\", \\\"base64\\\"),\\n  }\\n];\\n\"},\"typeVersion\":2},{\"id\":\"760536f8-c3f4-4d24-be36-4ac08004eb48\",\"name\":\"Decryption Code\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1320,860],\"parameters\":{\"jsCode\":\"const crypto = require(\\\"crypto\\\");\\n\\nconst privateKey = `-----BEGIN PRIVATE KEY-----\\n[INSERT YOUR KEY HERE]\\n-----END PRIVATE KEY-----`;\\n\\n// Convert input buffers\\nconst encryptedAesKeyBuffer = Buffer.from($json.encryptedAesKey.data);\\nconst initialVector = Buffer.from($json.initialVector.data);\\nconst encryptedFlowData = Buffer.from($json.encryptedFlowData.data);\\n\\n// Check if encrypted AES key, IV, and encrypted flow data exist\\nif (!encryptedAesKeyBuffer || !initialVector || !encryptedFlowData) {\\n  throw new Error(\\\"Missing required data (encrypted AES key, IV, or flow data)\\\");\\n}\\n\\n// Decrypt AES key using RSA\\nconst decryptedKey = crypto.privateDecrypt(\\n  {\\n    key: privateKey,\\n    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\\n    oaepHash: \\\"sha256\\\",\\n  },\\n  encryptedAesKeyBuffer\\n);\\n\\n// Ensure AES key is exactly 16 bytes (AES-128 requires it)\\nconst aesKey = decryptedKey.slice(0, 16);\\nif (aesKey.length !== 16) {\\n  throw new Error(\\\"Invalid AES Key length\\\");\\n}\\n\\n// Handle initialization vector (IV): If needed, flip the IV bits (standardize behavior)\\nconst standardizedIv = Buffer.from(initialVector);\\nif (standardizedIv.length !== 16) {\\n  throw new Error(\\\"Invalid IV length, must be 16 bytes\\\");\\n}\\n\\n// Extract the last 16 bytes as the authentication tag (GCM uses 16-byte tags)\\nconst authTag = encryptedFlowData.slice(-16);\\nconst encryptedDataWithoutTag = encryptedFlowData.slice(0, -16);\\n\\n// AES Decryption\\nconst decipher = crypto.createDecipheriv(\\\"aes-128-gcm\\\", aesKey, standardizedIv);\\ndecipher.setAuthTag(authTag);\\n\\nlet decrypted;\\ntry {\\n  decrypted = Buffer.concat([\\n    decipher.update(encryptedDataWithoutTag),\\n    decipher.final(),\\n  ]);\\n} catch (error) {\\n  throw new Error(\\\"Decryption failed: \\\" + error.message);\\n}\\n\\nreturn [{ \\n  decryptedPayload: decrypted.toString(\\\"utf-8\\\"),\\n  aesKey: aesKey.toString(\\\"base64\\\")\\n}];\\n\"},\"typeVersion\":2},{\"id\":\"17c055f3-c278-48c4-89d4-d305a35bc526\",\"name\":\"Encrypt Return\",\"type\":\"n8n-nodes-base.code\",\"position\":[-200,760],\"parameters\":{\"jsCode\":\"const crypto = require(\\\"crypto\\\");\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\n\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\n// Check if 'data' is a property of initialVector\\nconst ivData = initialVector.data || initialVector; // Fallback to initialVector if no 'data' property\\n\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\n// Check for various formats of initialVector\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\n// Invert Initialization Vector\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF)); // Ensure the result stays a valid byte\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\n\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Extract data from the input with proper error handling\\nlet date = \\\"2025-03-14\\\"; // Default fallback date\\nlet startTimes = []; // Default empty array for start times\\n\\n// Check if $json exists and has the expected structure\\nif ($json) {\\n    // Check if $json is an array\\n    if (Array.isArray($json) && $json.length > 0) {\\n        const appointmentData = $json[0];\\n        if (appointmentData && appointmentData.appointment_date) {\\n            date = appointmentData.appointment_date;\\n        }\\n        if (appointmentData && Array.isArray(appointmentData.start_times)) {\\n            startTimes = appointmentData.start_times;\\n        }\\n    } else if ($json.appointment_date) {\\n        // If $json is not an array but has appointment_date directly\\n        date = $json.appointment_date;\\n        if (Array.isArray($json.start_times)) {\\n            startTimes = $json.start_times;\\n        }\\n    }\\n}\\n\\n// Log the structure of $json for debugging\\nconsole.log(\\\"Input JSON structure:\\\", JSON.stringify($json, null, 2));\\n\\n// Ensure we have time slots (use defaults if none found)\\nif (!startTimes.length) {\\n    console.log(\\\"No time slots found in input, using defaults\\\");\\n    startTimes = [\\\"12:00:00\\\", \\\"12:30:00\\\", \\\"13:30:00\\\", \\\"14:00:00\\\"];\\n}\\n\\n// Map the time slots to the required format\\nconst timeSlots = startTimes.map((timeString, index) => ({\\n    id: `time_${index + 1}`,\\n    title: timeString\\n}));\\n\\n// Map the date slots for each time slot\\nconst dateSlots = [{\\n    id: \\\"date_1\\\",\\n    title: date\\n}];\\n\\n// Define the response data with the extracted time and date\\nconst responseData = {\\n    status: \\\"active\\\",\\n    time: timeSlots,\\n    date: dateSlots\\n};\\n\\n// Define the flow_token (accessed from the correct path)\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\"; // Fetch the flow_token dynamically from the path\\n\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\n// Define the next screen (this should be based on your flow logic)\\nconst nextScreen = \\\"APPOINTMENT\\\"; // You can set this dynamically depending on the flow\\n\\n// Define Response Message (updated to match the required response format)\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\", // Fixed version as per your requirements\\n    action: \\\"data_exchange\\\", // Since we're responding to a data exchange request\\n    screen: nextScreen, // The next screen that the user will be redirected to\\n    data: responseData, // Data to send back (includes the time and date)\\n    flow_token: flowToken, // Flow token for session identification\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\n// Get the authentication tag\\nconst authTag = cipher.getAuthTag();\\n\\n// Append the authentication tag to the encrypted response\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\n\\n// Encode the entire response as Base64\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the Base64-encoded response as the body\\nreturn [{ body: base64Response }];\\n\"},\"typeVersion\":2},{\"id\":\"412f55e3-5867-4e65-a494-3e3bf991d59c\",\"name\":\"Encrypt Return1\",\"type\":\"n8n-nodes-base.code\",\"position\":[-200,1000],\"parameters\":{\"jsCode\":\"const crypto = require(\\\"crypto\\\");\\n\\nconst jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\nif (!seats || !Array.isArray(seats) || seats.length === 0) {\\n    throw new Error(\\\"Seats data is missing or invalid.\\\");\\n}\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\nconst ivData = initialVector.data || initialVector;\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF));\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Define the response data with the extracted seats\\nconst responseData = {\\n    status: \\\"active\\\",\\n    seats: seats.map((seat, index) => ({\\n        id: `seat_${index + 1}`,\\n        title: seat\\n    }))\\n};\\n\\n// Define the flow_token\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\";\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\nconst nextScreen = \\\"SUMMARY\\\";\\n\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\",\\n    action: \\\"data_exchange\\\",\\n    screen: nextScreen,\\n    data: responseData,\\n    flow_token: flowToken,\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\nconst authTag = cipher.getAuthTag();\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the encrypted response\\nreturn [{ body: base64Response }];\\n\"},\"typeVersion\":2},{\"id\":\"6c130dfe-bec9-4ca5-af1a-9b55ed593b84\",\"name\":\"Sticky Note\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-2480,140],\"parameters\":{\"width\":580,\"height\":1900,\"content\":\"## Try it out\\n\\n### ðŸ”— **1. Webhook Entry & Initial Decryption Block**\\n\\n**Nodes involved:**\\n\\n* `Webhook1`\\n* `move to base64`\\n* `[partially visible node for decryption using RSA + AES]`\\n\\n**Description:**\\n\\nThe workflow begins with the `Webhook1` node, which listens for incoming HTTP POST requests. These requests typically contain encrypted data that needs to be decoded to proceed with processing.\\n\\nOnce received, the `move to base64` node reformats the incoming encrypted components (`encrypted_flow_data`, `encrypted_aes_key`, and `initial_vector`) into binary buffers. These are required inputs for decryption.\\n\\nThen, the custom JavaScript code (cut off in your snippet) uses a private RSA key to decrypt the AES key, which in turn is used to decrypt the actual data payload (likely using AES-GCM). This is a secure hybrid encryption methodâ€”RSA for key exchange, AES for data encryption.\\n\\n---\\n\\n### ðŸ§  **2. Payload Parsing & Preprocessing Block**\\n\\n**Node involved:**\\n\\n* `Json Parser`\\n\\n**Description:**\\n\\nHere, we take the decrypted JSON payload from Whatsapp Flows and parse key elements from it. This helps standardize and clean the input before deciding what kind of logic or response should follow based on user interaction.\\n\\n---\\n\\n### ðŸ”€ **3. Flow Decision Block**\\n\\n**Node involved:**\\n\\n* `Switch`\\n\\n**Description:**\\n\\nThis decision-making node routes the workflow depending on the screen context extracted earlier.\\n\\nE.g., If the screen where the user is exchanging information is appointment date:\\n\\n* `\\\"APPOINTMENT\\\"` â†’ follow the logic that handles scheduling data.\\n\\nThis allows dynamic routing within the workflow, making it adaptable to different user journey steps or screens.\\n\\n---\\n\\n### ðŸ“† **4. Appointment Data Handling Block**\\n\\n**Nodes involved:**\\n\\n* `Data Extraction Code`\\n* `Respond to Webhook1`\\n\\n**Description:**\\n\\nWhen the screen is `\\\"APPOINTMENT\\\"`, the `Data Extraction Code` node processes appointment dataâ€”typically grouping appointment slots by date. This is useful for summarizing available times, perhaps to show a user a calendar view of options.\\n\\nThe results are then sent back as a plain text response using `Respond to Webhook1`, which finalizes the API call and ensures a secure end-to-end interaction using Whatsapp Flows.\\n\\n\\n### ðŸ§© **Summary**\\n\\nThis n8n workflow handles encrypted user interactions and adapts dynamically based on the screen or step the user is currently in. Here's the general pattern:\\n\\n1. **Webhook receives encrypted data**\\n2. **Data is decrypted using hybrid RSA-AES encryption**\\n3. **Parsed to extract the current step (`screen`)**\\n4. **Conditional logic decides which path to follow**\\n5. **Extracts relevant information (e.g., appointments)**\\n6. **Returns response back to the user interface or chatbot**\\n\"},\"typeVersion\":1}],\"pinData\":{\"Webhook1\":[{\"body\":{\"initial_vector\":\"PFfPS7sPwJqYWLySIGWF/Q==\",\"encrypted_aes_key\":\"A2BJ/NRN0WsSHZ8KeH1mUreTHICGMprbvh8BP7vEAIyIxeADgtYODJNkJ5P77WsAtJkIx8BwibiWlPfdJlBFaYeQx86hllirf4GygagECsgEJyNX0B98rpx/0eic4FqdR/8bqDWNFZbi7i78vMDG4x+9PArJIwkXWtzuLaLtM2J5j/SAx2y3PV5pKeYqcfg7w/uYlubmkKZjJYuSLmIOHbdO5mmvblDBm8ap5COVvEzK18K3VYyT8BVzawUgfxxhlyCBd7bB36vcS8iKkTl6EFgkPqFmpcCOmZNSmnsJ5tu+e7uRX8OgwryqbFNfb/plZGUPTQJZlrObFO8rw22yJQ==\",\"encrypted_flow_data\":\"tkGedq3MER+FadPJh3W6amE18m0x1Xzge6cqPeb5sNkBgOfTtHkRrHuuLjrLG+MvOd9oSzFXdx4sT90cliJSLfp0uUBtVCnBT33Qa5PF87E/iNRtyOCW4Jcp1yv1po54jSVWnVjhgZRCt9akyjBYK1v2YJW5qxarsvFDFsZMsEOOMMOLtOWHGgGGS+tKR5PB7X4WwMHrlCLG9j0yT1U=\"},\"query\":{},\"params\":{},\"headers\":{\"host\":\"n8n.doubleit.com.br\",\"accept\":\"*/*\",\"connection\":\"upgrade\",\"user-agent\":\"facebookexternalua\",\"content-type\":\"application/json\",\"content-length\":\"657\",\"accept-encoding\":\"deflate, gzip\",\"x-hub-signature\":\"sha256=8e8d012f89e53d0a67aa31c19b472636e55b2e86e1569af9b200eb65839a39ce\",\"x-hub-signature-256\":\"sha256=5deea4ea13d95f1da43be49579528f5928e29cb7772abd2455d319ff7396df4e\"},\"webhookUrl\":\"https://n8n.doubleit.com.br/webhook/flow\",\"executionMode\":\"production\"}]},\"connections\":{\"Switch\":{\"main\":[[{\"node\":\"Data Extraction Code\",\"type\":\"main\",\"index\":0}],[{\"node\":\"Data Extraction Code1\",\"type\":\"main\",\"index\":0}]]},\"Webhook1\":{\"main\":[[{\"node\":\"move to base64\",\"type\":\"main\",\"index\":0}]]},\"Json Parser\":{\"main\":[[{\"node\":\"Switch\",\"type\":\"main\",\"index\":0}]]},\"Encrypt Return\":{\"main\":[[{\"node\":\"Respond to Webhook1\",\"type\":\"main\",\"index\":0}]]},\"move to base64\":{\"main\":[[{\"node\":\"Decryption Code\",\"type\":\"main\",\"index\":0}]]},\"Decryption Code\":{\"main\":[[{\"node\":\"Json Parser\",\"type\":\"main\",\"index\":0}]]},\"Encrypt Return1\":{\"main\":[[{\"node\":\"Respond to Webhook2\",\"type\":\"main\",\"index\":0}]]},\"Data Extraction Code\":{\"main\":[[{\"node\":\"Encrypt Return\",\"type\":\"main\",\"index\":0}]]},\"Data Extraction Code1\":{\"main\":[[{\"node\":\"Encrypt Return1\",\"type\":\"main\",\"index\":0}]]}}}",
  "readme": "# WhatsApp Flows Encrypted Data Exchange Workflow\n\n## Summary\n\nThis workflow enables secure end-to-end encrypted data exchange with WhatsApp Flows for interactive applications inside Whatsapp. It implements the WhatsApp Business Encryption protocol using RSA for key exchange and AES-GCM for payload encryption, providing a secure channel for sensitive data transmission while interfacing with WhatsApp's Business API. This follows the official WhatsApp Business Encryption specifications to establish an encrypted GraphQL-powered data exchange channel between your business and the WhatsApp consumer client.\n\n## How It Works\n\n### Encryption Flow\n\n  1. **Webhook Reception** : Receives encrypted data from WhatsApp containing:\n\n    * `encrypted_flow_data`: The AES-encrypted payload\n    * `encrypted_aes_key`: The RSA-encrypted AES key\n    * `initial_vector`: Initialization vector for AES decryption\n  2. **Decryption Process** :\n\n    * The workflow decrypts the AES key using an RSA private key\n    * Then uses this AES key to decrypt the payload data\n    * The inverted IV is used for response encryption\n  3. **Data Processing** :\n\n    * The workflow parses the decrypted JSON data\n    * Routes requests based on the `screen` parameter.\n  4. **Response Generation** :\n\n    * Generates appropriate response data based on the request type\n    * Encrypts the response using the same AES key and inverted IV\n    * Returns the base64-encoded encrypted response\n\n\n\n### Key Components\n\n  * **Webhook Endpoint** : Entry point for encrypted WhatsApp requests\n  * **Decryption Pipeline** : RSA and AES decryption components\n  * **Business Logic Router** : Screen-based routing for different functionality\n  * **Encryption Pipeline** : Secure response encryption\n\n\n\n## How to Use\n\n  1. **Deploy the Workflow** :\n\n    * Import the workflow JSON into your n8n instance\n  2. **Set Up WhatsApp Integration** :\n\n    * Configure your WhatsApp Business API to send requests to your n8n webhook URL\n    * Ensure your WhatsApp integration is set up to encrypt data using the public key pair of the private key used in this workflow\n  3. **Test the Flow** :\n\n    * Send an encrypted test message from WhatsApp to verify connectivity\n    * Check if appointment data is being retrieved correctly\n    * Validate that seat selection is functioning as expected\n  4. **Production Use** :\n\n    * Monitor the workflow performance in production\n    * Set up error notification if needed\n\n\n\n## Requirements\n\nAuthentication Keys\n\nRSA Private Key: Required for decrypting the AES key (included in the workflow)  \nWhatsApp Business Public Key: Must be registered with the WhatsApp Business API  \nPostgreSQL Credentials: For accessing appointment data from the database\n\nWhatsApp Business Encryption Setup  \nAs specified in the WhatsApp Business Encryption documentation:\n\nGenerate a 2048-bit RSA Key Pair:\n\nThe private key remains with your business (used in this workflow)  \nThe public key is shared with WhatsApp\n\nRegister the Public Key with WhatsApp:\n\nUse the WhatsApp Cloud API to register your public key  \nSet up the public key using the /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption endpoint\n\nKey Registration API Call:  \nPOST /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption  \n{  \n\"business_public_key\": \"YOUR_PUBLIC_KEY\"  \n}\n\nVerification:\n\nVerify your public key is registered using a GET request to the same endpoint  \nEnsure the key status is \"active\"\n",
  "readme_html": "<!--[--><div data-v-859c7806=\"\"><h1>WhatsApp Flows Encrypted Data Exchange Workflow</h1>\n<h2>Summary</h2>\n<p>This workflow enables secure end-to-end encrypted data exchange with WhatsApp Flows for interactive applications inside Whatsapp.  It implements the WhatsApp Business Encryption protocol using RSA for key exchange and AES-GCM for payload encryption, providing a secure channel for sensitive data transmission while interfacing with WhatsApp's Business API. This follows the official WhatsApp Business Encryption specifications to establish an encrypted GraphQL-powered data exchange channel between your business and the WhatsApp consumer client.</p>\n<h2>How It Works</h2>\n<h3>Encryption Flow</h3>\n<ol>\n<li>\n<p><strong>Webhook Reception</strong>: Receives encrypted data from WhatsApp containing:</p>\n<ul>\n<li><code>encrypted_flow_data</code>: The AES-encrypted payload</li>\n<li><code>encrypted_aes_key</code>: The RSA-encrypted AES key</li>\n<li><code>initial_vector</code>: Initialization vector for AES decryption</li>\n</ul>\n</li>\n<li>\n<p><strong>Decryption Process</strong>:</p>\n<ul>\n<li>The workflow decrypts the AES key using an RSA private key</li>\n<li>Then uses this AES key to decrypt the payload data</li>\n<li>The inverted IV is used for response encryption</li>\n</ul>\n</li>\n<li>\n<p><strong>Data Processing</strong>:</p>\n<ul>\n<li>The workflow parses the decrypted JSON data</li>\n<li>Routes requests based on the <code>screen</code> parameter.</li>\n</ul>\n</li>\n<li>\n<p><strong>Response Generation</strong>:</p>\n<ul>\n<li>Generates appropriate response data based on the request type</li>\n<li>Encrypts the response using the same AES key and inverted IV</li>\n<li>Returns the base64-encoded encrypted response</li>\n</ul>\n</li>\n</ol>\n<h3>Key Components</h3>\n<ul>\n<li><strong>Webhook Endpoint</strong>: Entry point for encrypted WhatsApp requests</li>\n<li><strong>Decryption Pipeline</strong>: RSA and AES decryption components</li>\n<li><strong>Business Logic Router</strong>: Screen-based routing for different functionality</li>\n<li><strong>Encryption Pipeline</strong>: Secure response encryption</li>\n</ul>\n<h2>How to Use</h2>\n<ol>\n<li>\n<p><strong>Deploy the Workflow</strong>:</p>\n<ul>\n<li>Import the workflow JSON into your n8n instance</li>\n</ul>\n</li>\n<li>\n<p><strong>Set Up WhatsApp Integration</strong>:</p>\n<ul>\n<li>Configure your WhatsApp Business API to send requests to your n8n webhook URL</li>\n<li>Ensure your WhatsApp integration is set up to encrypt data using the public key pair of the private key used in this workflow</li>\n</ul>\n</li>\n<li>\n<p><strong>Test the Flow</strong>:</p>\n<ul>\n<li>Send an encrypted test message from WhatsApp to verify connectivity</li>\n<li>Check if appointment data is being retrieved correctly</li>\n<li>Validate that seat selection is functioning as expected</li>\n</ul>\n</li>\n<li>\n<p><strong>Production Use</strong>:</p>\n<ul>\n<li>Monitor the workflow performance in production</li>\n<li>Set up error notification if needed</li>\n</ul>\n</li>\n</ol>\n<h2>Requirements</h2>\n<p>Authentication Keys</p>\n<p>RSA Private Key: Required for decrypting the AES key (included in the workflow)<br>\nWhatsApp Business Public Key: Must be registered with the WhatsApp Business API<br>\nPostgreSQL Credentials: For accessing appointment data from the database</p>\n<p>WhatsApp Business Encryption Setup<br>\nAs specified in the WhatsApp Business Encryption documentation:</p>\n<p>Generate a 2048-bit RSA Key Pair:</p>\n<p>The private key remains with your business (used in this workflow)<br>\nThe public key is shared with WhatsApp</p>\n<p>Register the Public Key with WhatsApp:</p>\n<p>Use the WhatsApp Cloud API to register your public key<br>\nSet up the public key using the /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption endpoint</p>\n<p>Key Registration API Call:<br>\nPOST /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption<br>\n{<br>\n\"business_public_key\": \"YOUR_PUBLIC_KEY\"<br>\n}</p>\n<p>Verification:</p>\n<p>Verify your public key is registered using a GET request to the same endpoint<br>\nEnsure the key status is \"active\"</p>\n</div><!--]-->",
  "readme_zh": "# WhatsApp FlowsåŠ å¯†æ•°æ®äº¤æ¢å·¥ä½œæµ\n\n## æ¦‚è¿°\n\næœ¬å·¥ä½œæµå®žçŽ°ä¸ŽWhatsApp Flowsçš„å®‰å…¨ç«¯åˆ°ç«¯åŠ å¯†æ•°æ®äº¤æ¢ï¼Œç”¨äºŽWhatsAppå†…éƒ¨äº¤äº’å¼åº”ç”¨ã€‚é‡‡ç”¨WhatsAppå•†ä¸šåŠ å¯†åè®®ï¼Œä½¿ç”¨RSAè¿›è¡Œå¯†é’¥äº¤æ¢å’ŒAES-GCMè¿›è¡Œè´Ÿè½½åŠ å¯†ï¼Œåœ¨ä¸ŽWhatsAppå•†ä¸šAPIå¯¹æŽ¥æ—¶ä¸ºæ•æ„Ÿæ•°æ®ä¼ è¾“å»ºç«‹å®‰å…¨é€šé“ã€‚ä¸¥æ ¼éµå¾ªå®˜æ–¹WhatsAppå•†ä¸šåŠ å¯†è§„èŒƒï¼Œåœ¨å•†æˆ·ä¸ŽWhatsAppæ¶ˆè´¹è€…å®¢æˆ·ç«¯ä¹‹é—´æž„å»ºåŸºäºŽGraphQLçš„åŠ å¯†æ•°æ®äº¤æ¢é€šé“ã€‚\n\n## è¿ä½œåŽŸç†\n\n### åŠ å¯†æµç¨‹\n\n  1. **WebhookæŽ¥æ”¶** : æŽ¥æ”¶æ¥è‡ªWhatsAppçš„åŠ å¯†æ•°æ®åŒ…ï¼ŒåŒ…å«ï¼š\n    * `encrypted_flow_data` : AESåŠ å¯†çš„æœ‰æ•ˆè½½è·\n    * `encrypted_aes_key` : RSAåŠ å¯†çš„AESå¯†é’¥\n    * `initial_vector` : AESè§£å¯†åˆå§‹åŒ–å‘é‡\n  2. **è§£å¯†è¿‡ç¨‹** :\n    * ä½¿ç”¨RSAç§é’¥è§£å¯†AESå¯†é’¥\n    * ä½¿ç”¨è¯¥AESå¯†é’¥è§£å¯†æœ‰æ•ˆè½½è·æ•°æ®\n    * åè½¬IVå‘é‡ç”¨äºŽå“åº”åŠ å¯†\n  3. **æ•°æ®å¤„ç†** :\n    * è§£æžè§£å¯†åŽçš„JSONæ•°æ®\n    * æ ¹æ®`screen`å‚æ•°è·¯ç”±è¯·æ±‚\n  4. **å“åº”ç”Ÿæˆ** :\n    * æ ¹æ®è¯·æ±‚ç±»åž‹ç”Ÿæˆå¯¹åº”å“åº”æ•°æ®\n    * ä½¿ç”¨ç›¸åŒAESå¯†é’¥å’Œåè½¬IVåŠ å¯†å“åº”\n    * è¿”å›žBase64ç¼–ç çš„åŠ å¯†å“åº”\n\n### æ ¸å¿ƒç»„ä»¶\n\n  * **WebhookæŽ¥å…¥ç‚¹** : åŠ å¯†WhatsAppè¯·æ±‚çš„å…¥å£\n  * **è§£å¯†ç®¡é“** : RSAä¸ŽAESè§£å¯†ç»„ä»¶\n  * **ä¸šåŠ¡é€»è¾‘è·¯ç”±** : åŸºäºŽå±å¹•æ ‡è¯†çš„åŠŸèƒ½è·¯ç”±\n  * **åŠ å¯†ç®¡é“** : å®‰å…¨å“åº”åŠ å¯†ç³»ç»Ÿ\n\n## ä½¿ç”¨æŒ‡å—\n\n  1. **éƒ¨ç½²å·¥ä½œæµ** :\n    * å°†å·¥ä½œæµJSONå¯¼å…¥n8nå®žä¾‹\n  2. **é…ç½®WhatsAppé›†æˆ** :\n    * è®¾ç½®WhatsAppå•†ä¸šAPIå°†è¯·æ±‚å‘é€è‡³n8n webhook URL\n    * ç¡®ä¿WhatsAppé›†æˆä½¿ç”¨ä¸Žæœ¬å·¥ä½œæµç§é’¥é…å¯¹çš„å…¬é’¥åŠ å¯†æ•°æ®\n  3. **æµ‹è¯•æµç¨‹** :\n    * ä»ŽWhatsAppå‘é€åŠ å¯†æµ‹è¯•æ¶ˆæ¯éªŒè¯è¿žé€šæ€§\n    * æ£€æŸ¥é¢„çº¦æ•°æ®æ˜¯å¦æ­£ç¡®èŽ·å–\n    * éªŒè¯åº§ä½é€‰æ‹©åŠŸèƒ½æ˜¯å¦æ­£å¸¸\n  4. **ç”Ÿäº§çŽ¯å¢ƒä½¿ç”¨** :\n    * ç›‘æŽ§ç”Ÿäº§çŽ¯å¢ƒå·¥ä½œæµæ€§èƒ½\n    * æŒ‰éœ€è®¾ç½®é”™è¯¯é€šçŸ¥\n\n## å¿…å¤‡æ¡ä»¶\n\n### è®¤è¯å¯†é’¥\nRSAç§é’¥ï¼šç”¨äºŽè§£å¯†AESå¯†é’¥ï¼ˆå·²åŒ…å«åœ¨å·¥ä½œæµä¸­ï¼‰  \nWhatsAppå•†ä¸šå…¬é’¥ï¼šéœ€åœ¨WhatsAppå•†ä¸šAPIæ³¨å†Œ  \nPostgreSQLå‡­è¯ï¼šç”¨äºŽä»Žæ•°æ®åº“èŽ·å–é¢„çº¦æ•°æ®\n\n### WhatsAppå•†ä¸šåŠ å¯†è®¾ç½®\næŒ‰ç…§WhatsAppå•†ä¸šåŠ å¯†æ–‡æ¡£è¦æ±‚ï¼š\n\nç”Ÿæˆ2048ä½RSAå¯†é’¥å¯¹ï¼š\n- ç§é’¥ç”±å•†æˆ·ä¿ç®¡ï¼ˆç”¨äºŽæœ¬å·¥ä½œæµï¼‰\n- å…¬é’¥éœ€ä¸ŽWhatsAppå…±äº«\n\nå‘WhatsAppæ³¨å†Œå…¬é’¥ï¼š\n1. ä½¿ç”¨WhatsAppäº‘APIæ³¨å†Œå…¬é’¥\n2. é€šè¿‡/v17.0/{WhatsAppå•†ä¸šè´¦æˆ·ID}/whatsapp_business_encryptionç«¯ç‚¹è®¾ç½®å…¬é’¥\n\nå¯†é’¥æ³¨å†ŒAPIè°ƒç”¨ç¤ºä¾‹ï¼š  \nPOST /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption  \n{  \n\"business_public_key\": \"æ‚¨çš„å…¬é’¥\"  \n}\n\néªŒè¯æ­¥éª¤ï¼š\n1. é€šè¿‡GETè¯·æ±‚è‡³ç›¸åŒç«¯ç‚¹éªŒè¯å…¬é’¥æ³¨å†ŒçŠ¶æ€\n2. ç¡®ä¿å¯†é’¥çŠ¶æ€æ˜¾ç¤ºä¸º\"active\"",
  "title_zh": "åˆ©ç”¨WhatsApp Flowsç«¯åˆ°ç«¯åŠ å¯†æ‰“é€ å®‰å…¨äº’åŠ¨åº”ç”¨",
  "publish_date_zh": "æœ€è¿‘æ›´æ–°äºŽä¸€å¤©å‰",
  "workflow_json_zh": "{\n  \"meta\": {\n    \"instanceId\": \"32014bf2061907b54debfd6d86e0e8dc3f3ec9cdd9123c339fc7506178206d83\",\n    \"templateCredsSetupCompleted\": true\n  },\n  \"nodes\": [\n    {\n      \"id\": \"1874c66a-97f0-4a33-a4e9-ab27b950edb4\",\n      \"name\": \"Webhook1\",\n      \"type\": \"n8n-nodes-base.webhook\",\n      \"position\": [\n        -1820,\n        860\n      ],\n      \"webhookId\": \"7116a2e3-c07f-4638-9140-3548a7957d15\",\n      \"parameters\": {\n        \"path\": \"flow\",\n        \"options\": {\n          \"responseHeaders\": {\n            \"entries\": [\n              {\n                \"name\": \"Content-Type\",\n                \"value\": \"text/plain\"\n              }\n            ]\n          }\n        },\n        \"httpMethod\": \"POST\",\n        \"responseMode\": \"responseNode\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"ae85225c-addf-44e8-a60f-f9e0f07a9bc0\",\n      \"name\": \"Json Parser\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1060,\n        860\n      ],\n      \"parameters\": {\n        \"jsCode\": \"function processPayload(items) {\\n  // Create a new array to store the processed items\\n  const processedItems = [];\\n  \\n  // Process each item in the input array\\n  for (const item of items) {\\n    try {\\n      // Extract the decryptedPayload string from the current item\\n      const decryptedPayloadString = item.json.decryptedPayload;\\n      \\n      // Parse the decryptedPayload string into a JavaScript object\\n      const decryptedPayloadObject = JSON.parse(decryptedPayloadString);\\n      \\n      // Extract the date from the data object\\n      const date = decryptedPayloadObject.data.date;\\n      \\n      // Extract the screen value\\n      const screen = decryptedPayloadObject.screen;\\n\\n      // Extract the flow_token object\\n      const flow_token = decryptedPayloadObject.flow_token;\\n      \\n      // Create a new item with the extracted date and screen\\n      const newItem = {\\n        json: {\\n          date: date,\\n          screen: screen,\\n          flow_token: flow_token,\\n          // Optionally preserve original data\\n          originalPayload: item.json\\n        }\\n      };\\n      \\n      // Add the processed item to our array\\n      processedItems.push(newItem);\\n    } catch (error) {\\n      // If there's an error, create an item with error information\\n      processedItems.push({\\n        json: {\\n          error: error.message,\\n          originalItem: item.json\\n        }\\n      });\\n    }\\n  }\\n  \\n  return processedItems;\\n}\\n\\nreturn processPayload(items);\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"8ee86c97-ed4f-48d1-924f-4252e1c07aa5\",\n      \"name\": \"Switch\",\n      \"type\": \"n8n-nodes-base.switch\",\n      \"position\": [\n        -740,\n        860\n      ],\n      \"parameters\": {\n        \"rules\": {\n          \"values\": [\n            {\n              \"conditions\": {\n                \"options\": {\n                  \"version\": 2,\n                  \"leftValue\": \"\",\n                  \"caseSensitive\": true,\n                  \"typeValidation\": \"strict\"\n                },\n                \"combinator\": \"and\",\n                \"conditions\": [\n                  {\n                    \"id\": \"aa929857-8458-49da-a027-0b4d4a7f75f7\",\n                    \"operator\": {\n                      \"type\": \"string\",\n                      \"operation\": \"equals\"\n                    },\n                    \"leftValue\": \"={{ $json.screen }}\",\n                    \"rightValue\": \"APPOINTMENT\"\n                  }\n                ]\n              }\n            },\n            {\n              \"conditions\": {\n                \"options\": {\n                  \"version\": 2,\n                  \"leftValue\": \"\",\n                  \"caseSensitive\": true,\n                  \"typeValidation\": \"strict\"\n                },\n                \"combinator\": \"and\",\n                \"conditions\": [\n                  {\n                    \"id\": \"d83dd890-5ee5-480e-b338-efc5eb26b494\",\n                    \"operator\": {\n                      \"name\": \"filter.operator.equals\",\n                      \"type\": \"string\",\n                      \"operation\": \"equals\"\n                    },\n                    \"leftValue\": \"={{ $json.screen }}\",\n                    \"rightValue\": \"DATE_SELECTION_SCREEN\"\n                  }\n                ]\n              }\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"typeVersion\": 3.2\n    },\n    {\n      \"id\": \"76fad406-2591-4531-acab-01cbfcf41c3f\",\n      \"name\": \"Respond to Webhook1\",\n      \"type\": \"n8n-nodes-base.respondToWebhook\",\n      \"position\": [\n        40,\n        760\n      ],\n      \"parameters\": {\n        \"options\": {\n          \"responseCode\": 200\n        },\n        \"respondWith\": \"text\",\n        \"responseBody\": \"={{ $json.body }}\"\n      },\n      \"typeVersion\": 1.1\n    },\n    {\n      \"id\": \"56cb338a-9d7a-4f1a-9c55-5ca9db4f3560\",\n      \"name\": \"Data Extraction Code\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -400,\n        760\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const groupedAppointments = items.reduce((acc, { json: { appointment_date, start_time } }) => {\\n  const dateKey = new Date(appointment_date).toISOString().split('T')[0];\\n  if (!acc[dateKey]) {\\n    acc[dateKey] = [];\\n  }\\n  acc[dateKey].push(start_time);\\n  return acc;\\n}, {});\\n\\nreturn Object.entries(groupedAppointments).map(([date, times]) => ({\\n  json: { appointment_date: date, start_times: times }\\n}));\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"8bd15faf-3a9b-4bb4-ac83-c913a7373480\",\n      \"name\": \"Respond to Webhook2\",\n      \"type\": \"n8n-nodes-base.respondToWebhook\",\n      \"position\": [\n        40,\n        1000\n      ],\n      \"parameters\": {\n        \"options\": {\n          \"responseCode\": 200\n        },\n        \"respondWith\": \"text\",\n        \"responseBody\": \"={{ $json.body }}\"\n      },\n      \"typeVersion\": 1.1\n    },\n    {\n      \"id\": \"67b06ae5-81c1-4efd-993e-a54e36bc5ce7\",\n      \"name\": \"Data Extraction Code1\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -400,\n        1000\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\n// Return the result properly formatted for n8n\\nreturn seats.map(seat => ({ json: { seat } }));\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"2d05f87c-a2c5-4790-9a85-c6cda46db927\",\n      \"name\": \"move to base64\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1600,\n        860\n      ],\n      \"parameters\": {\n        \"jsCode\": \"console.log($json);\\n\\nreturn [\\n  {\\n    encryptedFlowData: Buffer.from($json.body?.encrypted_flow_data || \\\"\\\", \\\"base64\\\"),\\n    encryptedAesKey: Buffer.from($json.body?.encrypted_aes_key || \\\"\\\", \\\"base64\\\"),\\n    initialVector: Buffer.from($json.body?.initial_vector || \\\"\\\", \\\"base64\\\"),\\n  }\\n];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"760536f8-c3f4-4d24-be36-4ac08004eb48\",\n      \"name\": \"Decryption Code\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1320,\n        860\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const crypto = require(\\\"crypto\\\");\\n\\nconst privateKey = `-----BEGIN PRIVATE KEY-----\\n[INSERT YOUR KEY HERE]\\n-----END PRIVATE KEY-----`;\\n\\n// Convert input buffers\\nconst encryptedAesKeyBuffer = Buffer.from($json.encryptedAesKey.data);\\nconst initialVector = Buffer.from($json.initialVector.data);\\nconst encryptedFlowData = Buffer.from($json.encryptedFlowData.data);\\n\\n// Check if encrypted AES key, IV, and encrypted flow data exist\\nif (!encryptedAesKeyBuffer || !initialVector || !encryptedFlowData) {\\n  throw new Error(\\\"Missing required data (encrypted AES key, IV, or flow data)\\\");\\n}\\n\\n// Decrypt AES key using RSA\\nconst decryptedKey = crypto.privateDecrypt(\\n  {\\n    key: privateKey,\\n    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\\n    oaepHash: \\\"sha256\\\",\\n  },\\n  encryptedAesKeyBuffer\\n);\\n\\n// Ensure AES key is exactly 16 bytes (AES-128 requires it)\\nconst aesKey = decryptedKey.slice(0, 16);\\nif (aesKey.length !== 16) {\\n  throw new Error(\\\"Invalid AES Key length\\\");\\n}\\n\\n// Handle initialization vector (IV): If needed, flip the IV bits (standardize behavior)\\nconst standardizedIv = Buffer.from(initialVector);\\nif (standardizedIv.length !== 16) {\\n  throw new Error(\\\"Invalid IV length, must be 16 bytes\\\");\\n}\\n\\n// Extract the last 16 bytes as the authentication tag (GCM uses 16-byte tags)\\nconst authTag = encryptedFlowData.slice(-16);\\nconst encryptedDataWithoutTag = encryptedFlowData.slice(0, -16);\\n\\n// AES Decryption\\nconst decipher = crypto.createDecipheriv(\\\"aes-128-gcm\\\", aesKey, standardizedIv);\\ndecipher.setAuthTag(authTag);\\n\\nlet decrypted;\\ntry {\\n  decrypted = Buffer.concat([\\n    decipher.update(encryptedDataWithoutTag),\\n    decipher.final(),\\n  ]);\\n} catch (error) {\\n  throw new Error(\\\"Decryption failed: \\\" + error.message);\\n}\\n\\nreturn [{ \\n  decryptedPayload: decrypted.toString(\\\"utf-8\\\"),\\n  aesKey: aesKey.toString(\\\"base64\\\")\\n}];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"17c055f3-c278-48c4-89d4-d305a35bc526\",\n      \"name\": \"Encrypt Return\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -200,\n        760\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const crypto = require(\\\"crypto\\\");\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\n\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\n// Check if 'data' is a property of initialVector\\nconst ivData = initialVector.data || initialVector; // Fallback to initialVector if no 'data' property\\n\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\n// Check for various formats of initialVector\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\n// Invert Initialization Vector\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF)); // Ensure the result stays a valid byte\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\n\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Extract data from the input with proper error handling\\nlet date = \\\"2025-03-14\\\"; // Default fallback date\\nlet startTimes = []; // Default empty array for start times\\n\\n// Check if $json exists and has the expected structure\\nif ($json) {\\n    // Check if $json is an array\\n    if (Array.isArray($json) && $json.length > 0) {\\n        const appointmentData = $json[0];\\n        if (appointmentData && appointmentData.appointment_date) {\\n            date = appointmentData.appointment_date;\\n        }\\n        if (appointmentData && Array.isArray(appointmentData.start_times)) {\\n            startTimes = appointmentData.start_times;\\n        }\\n    } else if ($json.appointment_date) {\\n        // If $json is not an array but has appointment_date directly\\n        date = $json.appointment_date;\\n        if (Array.isArray($json.start_times)) {\\n            startTimes = $json.start_times;\\n        }\\n    }\\n}\\n\\n// Log the structure of $json for debugging\\nconsole.log(\\\"Input JSON structure:\\\", JSON.stringify($json, null, 2));\\n\\n// Ensure we have time slots (use defaults if none found)\\nif (!startTimes.length) {\\n    console.log(\\\"No time slots found in input, using defaults\\\");\\n    startTimes = [\\\"12:00:00\\\", \\\"12:30:00\\\", \\\"13:30:00\\\", \\\"14:00:00\\\"];\\n}\\n\\n// Map the time slots to the required format\\nconst timeSlots = startTimes.map((timeString, index) => ({\\n    id: `time_${index + 1}`,\\n    title: timeString\\n}));\\n\\n// Map the date slots for each time slot\\nconst dateSlots = [{\\n    id: \\\"date_1\\\",\\n    title: date\\n}];\\n\\n// Define the response data with the extracted time and date\\nconst responseData = {\\n    status: \\\"active\\\",\\n    time: timeSlots,\\n    date: dateSlots\\n};\\n\\n// Define the flow_token (accessed from the correct path)\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\"; // Fetch the flow_token dynamically from the path\\n\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\n// Define the next screen (this should be based on your flow logic)\\nconst nextScreen = \\\"APPOINTMENT\\\"; // You can set this dynamically depending on the flow\\n\\n// Define Response Message (updated to match the required response format)\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\", // Fixed version as per your requirements\\n    action: \\\"data_exchange\\\", // Since we're responding to a data exchange request\\n    screen: nextScreen, // The next screen that the user will be redirected to\\n    data: responseData, // Data to send back (includes the time and date)\\n    flow_token: flowToken, // Flow token for session identification\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\n// Get the authentication tag\\nconst authTag = cipher.getAuthTag();\\n\\n// Append the authentication tag to the encrypted response\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\n\\n// Encode the entire response as Base64\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the Base64-encoded response as the body\\nreturn [{ body: base64Response }];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"412f55e3-5867-4e65-a494-3e3bf991d59c\",\n      \"name\": \"Encrypt Return1\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -200,\n        1000\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const crypto = require(\\\"crypto\\\");\\n\\nconst jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\nif (!seats || !Array.isArray(seats) || seats.length === 0) {\\n    throw new Error(\\\"Seats data is missing or invalid.\\\");\\n}\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\nconst ivData = initialVector.data || initialVector;\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF));\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Define the response data with the extracted seats\\nconst responseData = {\\n    status: \\\"active\\\",\\n    seats: seats.map((seat, index) => ({\\n        id: `seat_${index + 1}`,\\n        title: seat\\n    }))\\n};\\n\\n// Define the flow_token\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\";\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\nconst nextScreen = \\\"SUMMARY\\\";\\n\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\",\\n    action: \\\"data_exchange\\\",\\n    screen: nextScreen,\\n    data: responseData,\\n    flow_token: flowToken,\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\nconst authTag = cipher.getAuthTag();\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the encrypted response\\nreturn [{ body: base64Response }];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"6c130dfe-bec9-4ca5-af1a-9b55ed593b84\",\n      \"name\": \"Sticky Note\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -2480,\n        140\n      ],\n      \"parameters\": {\n        \"width\": 580,\n        \"height\": 1900,\n        \"content\": \"## è¯•ç”¨æµç¨‹\\n\\n### ðŸ”— **1. Webhookå…¥å£ä¸Žåˆå§‹è§£å¯†æ¨¡å—**\\n\\n**æ¶‰åŠèŠ‚ç‚¹:**\\n* `Webhook1`\\n* `è½¬ä¸ºbase64`\\n* `[éƒ¨åˆ†å¯è§çš„RSA+AESè§£å¯†èŠ‚ç‚¹]`\\n\\n**è¯´æ˜Ž:**\\næµç¨‹å§‹äºŽç›‘å¬HTTP POSTè¯·æ±‚çš„`Webhook1`èŠ‚ç‚¹ï¼Œè¿™äº›è¯·æ±‚é€šå¸¸åŒ…å«éœ€è¦è§£ç çš„åŠ å¯†æ•°æ®ã€‚æ”¶åˆ°æ•°æ®åŽï¼Œ`è½¬ä¸ºbase64`èŠ‚ç‚¹å°†åŠ å¯†ç»„ä»¶(`encrypted_flow_data`, `encrypted_aes_key`, `initial_vector`)é‡æ–°æ ¼å¼åŒ–ä¸ºäºŒè¿›åˆ¶ç¼“å†²åŒºï¼Œä½œä¸ºè§£å¯†å¿…éœ€è¾“å…¥ã€‚\\n\\néšåŽï¼ˆæˆªå›¾ä¸­æœªå®Œæ•´æ˜¾ç¤ºï¼‰çš„JavaScriptä»£ç ä¼šä½¿ç”¨RSAç§é’¥è§£å¯†AESå¯†é’¥ï¼Œè¿›è€Œè§£å¯†å®žé™…æ•°æ®è½½è·ï¼ˆå¯èƒ½é‡‡ç”¨AES-GCMç®—æ³•ï¼‰ã€‚è¿™æ˜¯å…¸åž‹çš„å®‰å…¨æ··åˆåŠ å¯†æ–¹æ¡ˆâ€”â€”RSAç”¨äºŽå¯†é’¥äº¤æ¢ï¼ŒAESç”¨äºŽæ•°æ®åŠ å¯†ã€‚\\n\\n---\\n\\n### ðŸ§  **2. è½½è·è§£æžä¸Žé¢„å¤„ç†æ¨¡å—**\\n\\n**æ¶‰åŠèŠ‚ç‚¹:**\\n* `JSONè§£æžå™¨`\\n\\n**è¯´æ˜Ž:**\\næ­¤æ¨¡å—å¯¹Whatsapp Flowsè§£å¯†åŽçš„JSONè½½è·è¿›è¡Œè§£æžï¼Œæå–å…³é”®å…ƒç´ ï¼Œåœ¨æ ¹æ®ç”¨æˆ·äº¤äº’å†³å®šåŽç»­é€»è¾‘æˆ–å“åº”å‰å®žçŽ°è¾“å…¥æ ‡å‡†åŒ–ã€‚\\n\\n---\\n\\n### ðŸ”€ **3. æµç¨‹å†³ç­–æ¨¡å—**\\n\\n**æ¶‰åŠèŠ‚ç‚¹:**\\n* `æ¡ä»¶åˆ†æ”¯`\\n\\n**è¯´æ˜Ž:**\\nè¯¥å†³ç­–èŠ‚ç‚¹æ ¹æ®å…ˆå‰æå–çš„å±å¹•ä¸Šä¸‹æ–‡è·¯ç”±å·¥ä½œæµã€‚ä¾‹å¦‚å½“ç”¨æˆ·å¤„äºŽé¢„çº¦æ—¥æœŸç•Œé¢æ—¶ï¼š\\n* `\\\"APPOINTMENT\\\"` â†’ æ‰§è¡Œé¢„çº¦æ•°æ®å¤„ç†é€»è¾‘\\nå®žçŽ°ç”¨æˆ·æ—…ç¨‹ä¸åŒæ­¥éª¤é—´çš„åŠ¨æ€è·¯ç”±é€‚é…ã€‚\\n\\n---\\n\\n### ðŸ“† **4. é¢„çº¦æ•°æ®å¤„ç†æ¨¡å—**\\n\\n**æ¶‰åŠèŠ‚ç‚¹:**\\n* `æ•°æ®æå–ä»£ç `\\n* `å“åº”Webhook1`\\n\\n**è¯´æ˜Ž:**\\nå½“å±å¹•ç±»åž‹ä¸º`\\\"APPOINTMENT\\\"`æ—¶ï¼Œ`æ•°æ®æå–ä»£ç `èŠ‚ç‚¹ä¼šå¤„ç†é¢„çº¦æ•°æ®ï¼ˆé€šå¸¸æŒ‰æ—¥æœŸåˆ†ç»„é¢„çº¦æ—¶æ®µï¼‰ï¼Œå¯ç”¨äºŽç”Ÿæˆæ—¥åŽ†è§†å›¾å±•ç¤ºå¯é€‰æ—¶é—´ã€‚\\n\\nå¤„ç†ç»“æžœé€šè¿‡`å“åº”Webhook1`ä»¥çº¯æ–‡æœ¬å½¢å¼è¿”å›žï¼Œç¡®ä¿Whatsapp Flowsç«¯åˆ°ç«¯çš„å®‰å…¨äº¤äº’é—­çŽ¯ã€‚\\n\\n### ðŸ§© **æµç¨‹æ¦‚è§ˆ**\\n\\nè¯¥n8nå·¥ä½œæµå¤„ç†åŠ å¯†ç”¨æˆ·äº¤äº’ï¼Œå¹¶æ ¹æ®å½“å‰æ‰€å¤„ç•Œé¢åŠ¨æ€é€‚é…ï¼Œé€šç”¨æ¨¡å¼å¦‚ä¸‹ï¼š\\n1. **WebhookæŽ¥æ”¶åŠ å¯†æ•°æ®**\\n2. **é‡‡ç”¨RSA-AESæ··åˆåŠ å¯†è¿›è¡Œè§£å¯†**\\n3. **è§£æžèŽ·å–å½“å‰æ­¥éª¤(`screen`)ä¿¡æ¯**\\n4. **æ¡ä»¶é€»è¾‘å†³å®šæ‰§è¡Œè·¯å¾„**\\n5. **æå–å…³é”®ä¿¡æ¯ï¼ˆå¦‚é¢„çº¦æ•°æ®ï¼‰**\\n6. **å°†å“åº”è¿”å›žç”¨æˆ·ç•Œé¢/èŠå¤©æœºå™¨äºº**\"\n      },\n      \"typeVersion\": 1\n    }\n  ],\n  \"pinData\": {\n    \"Webhook1\": [\n      {\n        \"body\": {\n          \"initial_vector\": \"PFfPS7sPwJqYWLySIGWF/Q==\",\n          \"encrypted_aes_key\": \"A2BJ/NRN0WsSHZ8KeH1mUreTHICGMprbvh8BP7vEAIyIxeADgtYODJNkJ5P77WsAtJkIx8BwibiWlPfdJlBFaYeQx86hllirf4GygagECsgEJyNX0B98rpx/0eic4FqdR/8bqDWNFZbi7i78vMDG4x+9PArJIwkXWtzuLaLtM2J5j/SAx2y3PV5pKeYqcfg7w/uYlubmkKZjJYuSLmIOHbdO5mmvblDBm8ap5COVvEzK18K3VYyT8BVzawUgfxxhlyCBd7bB36vcS8iKkTl6EFgkPqFmpcCOmZNSmnsJ5tu+e7uRX8OgwryqbFNfb/plZGUPTQJZlrObFO8rw22yJQ==\",\n          \"encrypted_flow_data\": \"tkGedq3MER+FadPJh3W6amE18m0x1Xzge6cqPeb5sNkBgOfTtHkRrHuuLjrLG+MvOd9oSzFXdx4sT90cliJSLfp0uUBtVCnBT33Qa5PF87E/iNRtyOCW4Jcp1yv1po54jSVWnVjhgZRCt9akyjBYK1v2YJW5qxarsvFDFsZMsEOOMMOLtOWHGgGGS+tKR5PB7X4WwMHrlCLG9j0yT1U=\"\n        },\n        \"query\": {},\n        \"params\": {},\n        \"headers\": {\n          \"host\": \"n8n.doubleit.com.br\",\n          \"accept\": \"*/*\",\n          \"connection\": \"upgrade\",\n          \"user-agent\": \"facebookexternalua\",\n          \"content-type\": \"application/json\",\n          \"content-length\": \"657\",\n          \"accept-encoding\": \"deflate, gzip\",\n          \"x-hub-signature\": \"sha256=8e8d012f89e53d0a67aa31c19b472636e55b2e86e1569af9b200eb65839a39ce\",\n          \"x-hub-signature-256\": \"sha256=5deea4ea13d95f1da43be49579528f5928e29cb7772abd2455d319ff7396df4e\"\n        },\n        \"webhookUrl\": \"https://n8n.doubleit.com.br/webhook/flow\",\n        \"executionMode\": \"production\"\n      }\n    ]\n  },\n  \"connections\": {\n    \"Switch\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Data Extraction Code\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"Data Extraction Code1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Webhook1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"move to base64\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Json Parser\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Switch\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Encrypt Return\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Respond to Webhook1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"move to base64\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Decryption Code\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Decryption Code\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Json Parser\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Encrypt Return1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Respond to Webhook2\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Data Extraction Code\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Encrypt Return\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Data Extraction Code1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Encrypt Return1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}"
}