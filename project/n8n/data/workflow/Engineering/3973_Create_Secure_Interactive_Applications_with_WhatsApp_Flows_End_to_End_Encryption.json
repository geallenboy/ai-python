{
  "title": "Create Secure Interactive Applications with WhatsApp Flows End-to-End Encryption",
  "url": "https://n8n.io/workflows/3973-create-secure-interactive-applications-with-whatsapp-flows-end-to-end-encryption/",
  "category": "Engineering",
  "category_url": "https://n8n.io/workflows/categories/engineering/?sort=createdAt:desc",
  "author": "Flavio Angeleu",
  "publish_date": "Last update a day ago",
  "publish_date_absolute": "",
  "content": "",
  "workflow_json": "{\"meta\":{\"instanceId\":\"32014bf2061907b54debfd6d86e0e8dc3f3ec9cdd9123c339fc7506178206d83\",\"templateCredsSetupCompleted\":true},\"nodes\":[{\"id\":\"1874c66a-97f0-4a33-a4e9-ab27b950edb4\",\"name\":\"Webhook1\",\"type\":\"n8n-nodes-base.webhook\",\"position\":[-1820,860],\"webhookId\":\"7116a2e3-c07f-4638-9140-3548a7957d15\",\"parameters\":{\"path\":\"flow\",\"options\":{\"responseHeaders\":{\"entries\":[{\"name\":\"Content-Type\",\"value\":\"text/plain\"}]}},\"httpMethod\":\"POST\",\"responseMode\":\"responseNode\"},\"typeVersion\":2},{\"id\":\"ae85225c-addf-44e8-a60f-f9e0f07a9bc0\",\"name\":\"Json Parser\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1060,860],\"parameters\":{\"jsCode\":\"function processPayload(items) {\\n  // Create a new array to store the processed items\\n  const processedItems = [];\\n  \\n  // Process each item in the input array\\n  for (const item of items) {\\n    try {\\n      // Extract the decryptedPayload string from the current item\\n      const decryptedPayloadString = item.json.decryptedPayload;\\n      \\n      // Parse the decryptedPayload string into a JavaScript object\\n      const decryptedPayloadObject = JSON.parse(decryptedPayloadString);\\n      \\n      // Extract the date from the data object\\n      const date = decryptedPayloadObject.data.date;\\n      \\n      // Extract the screen value\\n      const screen = decryptedPayloadObject.screen;\\n\\n      // Extract the flow_token object\\n      const flow_token = decryptedPayloadObject.flow_token;\\n      \\n      // Create a new item with the extracted date and screen\\n      const newItem = {\\n        json: {\\n          date: date,\\n          screen: screen,\\n          flow_token: flow_token,\\n          // Optionally preserve original data\\n          originalPayload: item.json\\n        }\\n      };\\n      \\n      // Add the processed item to our array\\n      processedItems.push(newItem);\\n    } catch (error) {\\n      // If there's an error, create an item with error information\\n      processedItems.push({\\n        json: {\\n          error: error.message,\\n          originalItem: item.json\\n        }\\n      });\\n    }\\n  }\\n  \\n  return processedItems;\\n}\\n\\nreturn processPayload(items);\"},\"typeVersion\":2},{\"id\":\"8ee86c97-ed4f-48d1-924f-4252e1c07aa5\",\"name\":\"Switch\",\"type\":\"n8n-nodes-base.switch\",\"position\":[-740,860],\"parameters\":{\"rules\":{\"values\":[{\"conditions\":{\"options\":{\"version\":2,\"leftValue\":\"\",\"caseSensitive\":true,\"typeValidation\":\"strict\"},\"combinator\":\"and\",\"conditions\":[{\"id\":\"aa929857-8458-49da-a027-0b4d4a7f75f7\",\"operator\":{\"type\":\"string\",\"operation\":\"equals\"},\"leftValue\":\"={{ $json.screen }}\",\"rightValue\":\"APPOINTMENT\"}]}},{\"conditions\":{\"options\":{\"version\":2,\"leftValue\":\"\",\"caseSensitive\":true,\"typeValidation\":\"strict\"},\"combinator\":\"and\",\"conditions\":[{\"id\":\"d83dd890-5ee5-480e-b338-efc5eb26b494\",\"operator\":{\"name\":\"filter.operator.equals\",\"type\":\"string\",\"operation\":\"equals\"},\"leftValue\":\"={{ $json.screen }}\",\"rightValue\":\"DATE_SELECTION_SCREEN\"}]}}]},\"options\":{}},\"typeVersion\":3.2},{\"id\":\"76fad406-2591-4531-acab-01cbfcf41c3f\",\"name\":\"Respond to Webhook1\",\"type\":\"n8n-nodes-base.respondToWebhook\",\"position\":[40,760],\"parameters\":{\"options\":{\"responseCode\":200},\"respondWith\":\"text\",\"responseBody\":\"={{ $json.body }}\"},\"typeVersion\":1.1},{\"id\":\"56cb338a-9d7a-4f1a-9c55-5ca9db4f3560\",\"name\":\"Data Extraction Code\",\"type\":\"n8n-nodes-base.code\",\"position\":[-400,760],\"parameters\":{\"jsCode\":\"const groupedAppointments = items.reduce((acc, { json: { appointment_date, start_time } }) => {\\n  const dateKey = new Date(appointment_date).toISOString().split('T')[0];\\n  if (!acc[dateKey]) {\\n    acc[dateKey] = [];\\n  }\\n  acc[dateKey].push(start_time);\\n  return acc;\\n}, {});\\n\\nreturn Object.entries(groupedAppointments).map(([date, times]) => ({\\n  json: { appointment_date: date, start_times: times }\\n}));\\n\"},\"typeVersion\":2},{\"id\":\"8bd15faf-3a9b-4bb4-ac83-c913a7373480\",\"name\":\"Respond to Webhook2\",\"type\":\"n8n-nodes-base.respondToWebhook\",\"position\":[40,1000],\"parameters\":{\"options\":{\"responseCode\":200},\"respondWith\":\"text\",\"responseBody\":\"={{ $json.body }}\"},\"typeVersion\":1.1},{\"id\":\"67b06ae5-81c1-4efd-993e-a54e36bc5ce7\",\"name\":\"Data Extraction Code1\",\"type\":\"n8n-nodes-base.code\",\"position\":[-400,1000],\"parameters\":{\"jsCode\":\"const jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\n// Return the result properly formatted for n8n\\nreturn seats.map(seat => ({ json: { seat } }));\\n\"},\"typeVersion\":2},{\"id\":\"2d05f87c-a2c5-4790-9a85-c6cda46db927\",\"name\":\"move to base64\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1600,860],\"parameters\":{\"jsCode\":\"console.log($json);\\n\\nreturn [\\n  {\\n    encryptedFlowData: Buffer.from($json.body?.encrypted_flow_data || \\\"\\\", \\\"base64\\\"),\\n    encryptedAesKey: Buffer.from($json.body?.encrypted_aes_key || \\\"\\\", \\\"base64\\\"),\\n    initialVector: Buffer.from($json.body?.initial_vector || \\\"\\\", \\\"base64\\\"),\\n  }\\n];\\n\"},\"typeVersion\":2},{\"id\":\"760536f8-c3f4-4d24-be36-4ac08004eb48\",\"name\":\"Decryption Code\",\"type\":\"n8n-nodes-base.code\",\"position\":[-1320,860],\"parameters\":{\"jsCode\":\"const crypto = require(\\\"crypto\\\");\\n\\nconst privateKey = `-----BEGIN PRIVATE KEY-----\\n[INSERT YOUR KEY HERE]\\n-----END PRIVATE KEY-----`;\\n\\n// Convert input buffers\\nconst encryptedAesKeyBuffer = Buffer.from($json.encryptedAesKey.data);\\nconst initialVector = Buffer.from($json.initialVector.data);\\nconst encryptedFlowData = Buffer.from($json.encryptedFlowData.data);\\n\\n// Check if encrypted AES key, IV, and encrypted flow data exist\\nif (!encryptedAesKeyBuffer || !initialVector || !encryptedFlowData) {\\n  throw new Error(\\\"Missing required data (encrypted AES key, IV, or flow data)\\\");\\n}\\n\\n// Decrypt AES key using RSA\\nconst decryptedKey = crypto.privateDecrypt(\\n  {\\n    key: privateKey,\\n    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\\n    oaepHash: \\\"sha256\\\",\\n  },\\n  encryptedAesKeyBuffer\\n);\\n\\n// Ensure AES key is exactly 16 bytes (AES-128 requires it)\\nconst aesKey = decryptedKey.slice(0, 16);\\nif (aesKey.length !== 16) {\\n  throw new Error(\\\"Invalid AES Key length\\\");\\n}\\n\\n// Handle initialization vector (IV): If needed, flip the IV bits (standardize behavior)\\nconst standardizedIv = Buffer.from(initialVector);\\nif (standardizedIv.length !== 16) {\\n  throw new Error(\\\"Invalid IV length, must be 16 bytes\\\");\\n}\\n\\n// Extract the last 16 bytes as the authentication tag (GCM uses 16-byte tags)\\nconst authTag = encryptedFlowData.slice(-16);\\nconst encryptedDataWithoutTag = encryptedFlowData.slice(0, -16);\\n\\n// AES Decryption\\nconst decipher = crypto.createDecipheriv(\\\"aes-128-gcm\\\", aesKey, standardizedIv);\\ndecipher.setAuthTag(authTag);\\n\\nlet decrypted;\\ntry {\\n  decrypted = Buffer.concat([\\n    decipher.update(encryptedDataWithoutTag),\\n    decipher.final(),\\n  ]);\\n} catch (error) {\\n  throw new Error(\\\"Decryption failed: \\\" + error.message);\\n}\\n\\nreturn [{ \\n  decryptedPayload: decrypted.toString(\\\"utf-8\\\"),\\n  aesKey: aesKey.toString(\\\"base64\\\")\\n}];\\n\"},\"typeVersion\":2},{\"id\":\"17c055f3-c278-48c4-89d4-d305a35bc526\",\"name\":\"Encrypt Return\",\"type\":\"n8n-nodes-base.code\",\"position\":[-200,760],\"parameters\":{\"jsCode\":\"const crypto = require(\\\"crypto\\\");\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\n\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\n// Check if 'data' is a property of initialVector\\nconst ivData = initialVector.data || initialVector; // Fallback to initialVector if no 'data' property\\n\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\n// Check for various formats of initialVector\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\n// Invert Initialization Vector\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF)); // Ensure the result stays a valid byte\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\n\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Extract data from the input with proper error handling\\nlet date = \\\"2025-03-14\\\"; // Default fallback date\\nlet startTimes = []; // Default empty array for start times\\n\\n// Check if $json exists and has the expected structure\\nif ($json) {\\n    // Check if $json is an array\\n    if (Array.isArray($json) && $json.length > 0) {\\n        const appointmentData = $json[0];\\n        if (appointmentData && appointmentData.appointment_date) {\\n            date = appointmentData.appointment_date;\\n        }\\n        if (appointmentData && Array.isArray(appointmentData.start_times)) {\\n            startTimes = appointmentData.start_times;\\n        }\\n    } else if ($json.appointment_date) {\\n        // If $json is not an array but has appointment_date directly\\n        date = $json.appointment_date;\\n        if (Array.isArray($json.start_times)) {\\n            startTimes = $json.start_times;\\n        }\\n    }\\n}\\n\\n// Log the structure of $json for debugging\\nconsole.log(\\\"Input JSON structure:\\\", JSON.stringify($json, null, 2));\\n\\n// Ensure we have time slots (use defaults if none found)\\nif (!startTimes.length) {\\n    console.log(\\\"No time slots found in input, using defaults\\\");\\n    startTimes = [\\\"12:00:00\\\", \\\"12:30:00\\\", \\\"13:30:00\\\", \\\"14:00:00\\\"];\\n}\\n\\n// Map the time slots to the required format\\nconst timeSlots = startTimes.map((timeString, index) => ({\\n    id: `time_${index + 1}`,\\n    title: timeString\\n}));\\n\\n// Map the date slots for each time slot\\nconst dateSlots = [{\\n    id: \\\"date_1\\\",\\n    title: date\\n}];\\n\\n// Define the response data with the extracted time and date\\nconst responseData = {\\n    status: \\\"active\\\",\\n    time: timeSlots,\\n    date: dateSlots\\n};\\n\\n// Define the flow_token (accessed from the correct path)\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\"; // Fetch the flow_token dynamically from the path\\n\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\n// Define the next screen (this should be based on your flow logic)\\nconst nextScreen = \\\"APPOINTMENT\\\"; // You can set this dynamically depending on the flow\\n\\n// Define Response Message (updated to match the required response format)\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\", // Fixed version as per your requirements\\n    action: \\\"data_exchange\\\", // Since we're responding to a data exchange request\\n    screen: nextScreen, // The next screen that the user will be redirected to\\n    data: responseData, // Data to send back (includes the time and date)\\n    flow_token: flowToken, // Flow token for session identification\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\n// Get the authentication tag\\nconst authTag = cipher.getAuthTag();\\n\\n// Append the authentication tag to the encrypted response\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\n\\n// Encode the entire response as Base64\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the Base64-encoded response as the body\\nreturn [{ body: base64Response }];\\n\"},\"typeVersion\":2},{\"id\":\"412f55e3-5867-4e65-a494-3e3bf991d59c\",\"name\":\"Encrypt Return1\",\"type\":\"n8n-nodes-base.code\",\"position\":[-200,1000],\"parameters\":{\"jsCode\":\"const crypto = require(\\\"crypto\\\");\\n\\nconst jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\nif (!seats || !Array.isArray(seats) || seats.length === 0) {\\n    throw new Error(\\\"Seats data is missing or invalid.\\\");\\n}\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\nconst ivData = initialVector.data || initialVector;\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF));\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Define the response data with the extracted seats\\nconst responseData = {\\n    status: \\\"active\\\",\\n    seats: seats.map((seat, index) => ({\\n        id: `seat_${index + 1}`,\\n        title: seat\\n    }))\\n};\\n\\n// Define the flow_token\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\";\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\nconst nextScreen = \\\"SUMMARY\\\";\\n\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\",\\n    action: \\\"data_exchange\\\",\\n    screen: nextScreen,\\n    data: responseData,\\n    flow_token: flowToken,\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\nconst authTag = cipher.getAuthTag();\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the encrypted response\\nreturn [{ body: base64Response }];\\n\"},\"typeVersion\":2},{\"id\":\"6c130dfe-bec9-4ca5-af1a-9b55ed593b84\",\"name\":\"Sticky Note\",\"type\":\"n8n-nodes-base.stickyNote\",\"position\":[-2480,140],\"parameters\":{\"width\":580,\"height\":1900,\"content\":\"## Try it out\\n\\n### 🔗 **1. Webhook Entry & Initial Decryption Block**\\n\\n**Nodes involved:**\\n\\n* `Webhook1`\\n* `move to base64`\\n* `[partially visible node for decryption using RSA + AES]`\\n\\n**Description:**\\n\\nThe workflow begins with the `Webhook1` node, which listens for incoming HTTP POST requests. These requests typically contain encrypted data that needs to be decoded to proceed with processing.\\n\\nOnce received, the `move to base64` node reformats the incoming encrypted components (`encrypted_flow_data`, `encrypted_aes_key`, and `initial_vector`) into binary buffers. These are required inputs for decryption.\\n\\nThen, the custom JavaScript code (cut off in your snippet) uses a private RSA key to decrypt the AES key, which in turn is used to decrypt the actual data payload (likely using AES-GCM). This is a secure hybrid encryption method—RSA for key exchange, AES for data encryption.\\n\\n---\\n\\n### 🧠 **2. Payload Parsing & Preprocessing Block**\\n\\n**Node involved:**\\n\\n* `Json Parser`\\n\\n**Description:**\\n\\nHere, we take the decrypted JSON payload from Whatsapp Flows and parse key elements from it. This helps standardize and clean the input before deciding what kind of logic or response should follow based on user interaction.\\n\\n---\\n\\n### 🔀 **3. Flow Decision Block**\\n\\n**Node involved:**\\n\\n* `Switch`\\n\\n**Description:**\\n\\nThis decision-making node routes the workflow depending on the screen context extracted earlier.\\n\\nE.g., If the screen where the user is exchanging information is appointment date:\\n\\n* `\\\"APPOINTMENT\\\"` → follow the logic that handles scheduling data.\\n\\nThis allows dynamic routing within the workflow, making it adaptable to different user journey steps or screens.\\n\\n---\\n\\n### 📆 **4. Appointment Data Handling Block**\\n\\n**Nodes involved:**\\n\\n* `Data Extraction Code`\\n* `Respond to Webhook1`\\n\\n**Description:**\\n\\nWhen the screen is `\\\"APPOINTMENT\\\"`, the `Data Extraction Code` node processes appointment data—typically grouping appointment slots by date. This is useful for summarizing available times, perhaps to show a user a calendar view of options.\\n\\nThe results are then sent back as a plain text response using `Respond to Webhook1`, which finalizes the API call and ensures a secure end-to-end interaction using Whatsapp Flows.\\n\\n\\n### 🧩 **Summary**\\n\\nThis n8n workflow handles encrypted user interactions and adapts dynamically based on the screen or step the user is currently in. Here's the general pattern:\\n\\n1. **Webhook receives encrypted data**\\n2. **Data is decrypted using hybrid RSA-AES encryption**\\n3. **Parsed to extract the current step (`screen`)**\\n4. **Conditional logic decides which path to follow**\\n5. **Extracts relevant information (e.g., appointments)**\\n6. **Returns response back to the user interface or chatbot**\\n\"},\"typeVersion\":1}],\"pinData\":{\"Webhook1\":[{\"body\":{\"initial_vector\":\"PFfPS7sPwJqYWLySIGWF/Q==\",\"encrypted_aes_key\":\"A2BJ/NRN0WsSHZ8KeH1mUreTHICGMprbvh8BP7vEAIyIxeADgtYODJNkJ5P77WsAtJkIx8BwibiWlPfdJlBFaYeQx86hllirf4GygagECsgEJyNX0B98rpx/0eic4FqdR/8bqDWNFZbi7i78vMDG4x+9PArJIwkXWtzuLaLtM2J5j/SAx2y3PV5pKeYqcfg7w/uYlubmkKZjJYuSLmIOHbdO5mmvblDBm8ap5COVvEzK18K3VYyT8BVzawUgfxxhlyCBd7bB36vcS8iKkTl6EFgkPqFmpcCOmZNSmnsJ5tu+e7uRX8OgwryqbFNfb/plZGUPTQJZlrObFO8rw22yJQ==\",\"encrypted_flow_data\":\"tkGedq3MER+FadPJh3W6amE18m0x1Xzge6cqPeb5sNkBgOfTtHkRrHuuLjrLG+MvOd9oSzFXdx4sT90cliJSLfp0uUBtVCnBT33Qa5PF87E/iNRtyOCW4Jcp1yv1po54jSVWnVjhgZRCt9akyjBYK1v2YJW5qxarsvFDFsZMsEOOMMOLtOWHGgGGS+tKR5PB7X4WwMHrlCLG9j0yT1U=\"},\"query\":{},\"params\":{},\"headers\":{\"host\":\"n8n.doubleit.com.br\",\"accept\":\"*/*\",\"connection\":\"upgrade\",\"user-agent\":\"facebookexternalua\",\"content-type\":\"application/json\",\"content-length\":\"657\",\"accept-encoding\":\"deflate, gzip\",\"x-hub-signature\":\"sha256=8e8d012f89e53d0a67aa31c19b472636e55b2e86e1569af9b200eb65839a39ce\",\"x-hub-signature-256\":\"sha256=5deea4ea13d95f1da43be49579528f5928e29cb7772abd2455d319ff7396df4e\"},\"webhookUrl\":\"https://n8n.doubleit.com.br/webhook/flow\",\"executionMode\":\"production\"}]},\"connections\":{\"Switch\":{\"main\":[[{\"node\":\"Data Extraction Code\",\"type\":\"main\",\"index\":0}],[{\"node\":\"Data Extraction Code1\",\"type\":\"main\",\"index\":0}]]},\"Webhook1\":{\"main\":[[{\"node\":\"move to base64\",\"type\":\"main\",\"index\":0}]]},\"Json Parser\":{\"main\":[[{\"node\":\"Switch\",\"type\":\"main\",\"index\":0}]]},\"Encrypt Return\":{\"main\":[[{\"node\":\"Respond to Webhook1\",\"type\":\"main\",\"index\":0}]]},\"move to base64\":{\"main\":[[{\"node\":\"Decryption Code\",\"type\":\"main\",\"index\":0}]]},\"Decryption Code\":{\"main\":[[{\"node\":\"Json Parser\",\"type\":\"main\",\"index\":0}]]},\"Encrypt Return1\":{\"main\":[[{\"node\":\"Respond to Webhook2\",\"type\":\"main\",\"index\":0}]]},\"Data Extraction Code\":{\"main\":[[{\"node\":\"Encrypt Return\",\"type\":\"main\",\"index\":0}]]},\"Data Extraction Code1\":{\"main\":[[{\"node\":\"Encrypt Return1\",\"type\":\"main\",\"index\":0}]]}}}",
  "readme": "# WhatsApp Flows Encrypted Data Exchange Workflow\n\n## Summary\n\nThis workflow enables secure end-to-end encrypted data exchange with WhatsApp Flows for interactive applications inside Whatsapp. It implements the WhatsApp Business Encryption protocol using RSA for key exchange and AES-GCM for payload encryption, providing a secure channel for sensitive data transmission while interfacing with WhatsApp's Business API. This follows the official WhatsApp Business Encryption specifications to establish an encrypted GraphQL-powered data exchange channel between your business and the WhatsApp consumer client.\n\n## How It Works\n\n### Encryption Flow\n\n  1. **Webhook Reception** : Receives encrypted data from WhatsApp containing:\n\n    * `encrypted_flow_data`: The AES-encrypted payload\n    * `encrypted_aes_key`: The RSA-encrypted AES key\n    * `initial_vector`: Initialization vector for AES decryption\n  2. **Decryption Process** :\n\n    * The workflow decrypts the AES key using an RSA private key\n    * Then uses this AES key to decrypt the payload data\n    * The inverted IV is used for response encryption\n  3. **Data Processing** :\n\n    * The workflow parses the decrypted JSON data\n    * Routes requests based on the `screen` parameter.\n  4. **Response Generation** :\n\n    * Generates appropriate response data based on the request type\n    * Encrypts the response using the same AES key and inverted IV\n    * Returns the base64-encoded encrypted response\n\n\n\n### Key Components\n\n  * **Webhook Endpoint** : Entry point for encrypted WhatsApp requests\n  * **Decryption Pipeline** : RSA and AES decryption components\n  * **Business Logic Router** : Screen-based routing for different functionality\n  * **Encryption Pipeline** : Secure response encryption\n\n\n\n## How to Use\n\n  1. **Deploy the Workflow** :\n\n    * Import the workflow JSON into your n8n instance\n  2. **Set Up WhatsApp Integration** :\n\n    * Configure your WhatsApp Business API to send requests to your n8n webhook URL\n    * Ensure your WhatsApp integration is set up to encrypt data using the public key pair of the private key used in this workflow\n  3. **Test the Flow** :\n\n    * Send an encrypted test message from WhatsApp to verify connectivity\n    * Check if appointment data is being retrieved correctly\n    * Validate that seat selection is functioning as expected\n  4. **Production Use** :\n\n    * Monitor the workflow performance in production\n    * Set up error notification if needed\n\n\n\n## Requirements\n\nAuthentication Keys\n\nRSA Private Key: Required for decrypting the AES key (included in the workflow)  \nWhatsApp Business Public Key: Must be registered with the WhatsApp Business API  \nPostgreSQL Credentials: For accessing appointment data from the database\n\nWhatsApp Business Encryption Setup  \nAs specified in the WhatsApp Business Encryption documentation:\n\nGenerate a 2048-bit RSA Key Pair:\n\nThe private key remains with your business (used in this workflow)  \nThe public key is shared with WhatsApp\n\nRegister the Public Key with WhatsApp:\n\nUse the WhatsApp Cloud API to register your public key  \nSet up the public key using the /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption endpoint\n\nKey Registration API Call:  \nPOST /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption  \n{  \n\"business_public_key\": \"YOUR_PUBLIC_KEY\"  \n}\n\nVerification:\n\nVerify your public key is registered using a GET request to the same endpoint  \nEnsure the key status is \"active\"\n",
  "readme_html": "<!--[--><div data-v-859c7806=\"\"><h1>WhatsApp Flows Encrypted Data Exchange Workflow</h1>\n<h2>Summary</h2>\n<p>This workflow enables secure end-to-end encrypted data exchange with WhatsApp Flows for interactive applications inside Whatsapp.  It implements the WhatsApp Business Encryption protocol using RSA for key exchange and AES-GCM for payload encryption, providing a secure channel for sensitive data transmission while interfacing with WhatsApp's Business API. This follows the official WhatsApp Business Encryption specifications to establish an encrypted GraphQL-powered data exchange channel between your business and the WhatsApp consumer client.</p>\n<h2>How It Works</h2>\n<h3>Encryption Flow</h3>\n<ol>\n<li>\n<p><strong>Webhook Reception</strong>: Receives encrypted data from WhatsApp containing:</p>\n<ul>\n<li><code>encrypted_flow_data</code>: The AES-encrypted payload</li>\n<li><code>encrypted_aes_key</code>: The RSA-encrypted AES key</li>\n<li><code>initial_vector</code>: Initialization vector for AES decryption</li>\n</ul>\n</li>\n<li>\n<p><strong>Decryption Process</strong>:</p>\n<ul>\n<li>The workflow decrypts the AES key using an RSA private key</li>\n<li>Then uses this AES key to decrypt the payload data</li>\n<li>The inverted IV is used for response encryption</li>\n</ul>\n</li>\n<li>\n<p><strong>Data Processing</strong>:</p>\n<ul>\n<li>The workflow parses the decrypted JSON data</li>\n<li>Routes requests based on the <code>screen</code> parameter.</li>\n</ul>\n</li>\n<li>\n<p><strong>Response Generation</strong>:</p>\n<ul>\n<li>Generates appropriate response data based on the request type</li>\n<li>Encrypts the response using the same AES key and inverted IV</li>\n<li>Returns the base64-encoded encrypted response</li>\n</ul>\n</li>\n</ol>\n<h3>Key Components</h3>\n<ul>\n<li><strong>Webhook Endpoint</strong>: Entry point for encrypted WhatsApp requests</li>\n<li><strong>Decryption Pipeline</strong>: RSA and AES decryption components</li>\n<li><strong>Business Logic Router</strong>: Screen-based routing for different functionality</li>\n<li><strong>Encryption Pipeline</strong>: Secure response encryption</li>\n</ul>\n<h2>How to Use</h2>\n<ol>\n<li>\n<p><strong>Deploy the Workflow</strong>:</p>\n<ul>\n<li>Import the workflow JSON into your n8n instance</li>\n</ul>\n</li>\n<li>\n<p><strong>Set Up WhatsApp Integration</strong>:</p>\n<ul>\n<li>Configure your WhatsApp Business API to send requests to your n8n webhook URL</li>\n<li>Ensure your WhatsApp integration is set up to encrypt data using the public key pair of the private key used in this workflow</li>\n</ul>\n</li>\n<li>\n<p><strong>Test the Flow</strong>:</p>\n<ul>\n<li>Send an encrypted test message from WhatsApp to verify connectivity</li>\n<li>Check if appointment data is being retrieved correctly</li>\n<li>Validate that seat selection is functioning as expected</li>\n</ul>\n</li>\n<li>\n<p><strong>Production Use</strong>:</p>\n<ul>\n<li>Monitor the workflow performance in production</li>\n<li>Set up error notification if needed</li>\n</ul>\n</li>\n</ol>\n<h2>Requirements</h2>\n<p>Authentication Keys</p>\n<p>RSA Private Key: Required for decrypting the AES key (included in the workflow)<br>\nWhatsApp Business Public Key: Must be registered with the WhatsApp Business API<br>\nPostgreSQL Credentials: For accessing appointment data from the database</p>\n<p>WhatsApp Business Encryption Setup<br>\nAs specified in the WhatsApp Business Encryption documentation:</p>\n<p>Generate a 2048-bit RSA Key Pair:</p>\n<p>The private key remains with your business (used in this workflow)<br>\nThe public key is shared with WhatsApp</p>\n<p>Register the Public Key with WhatsApp:</p>\n<p>Use the WhatsApp Cloud API to register your public key<br>\nSet up the public key using the /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption endpoint</p>\n<p>Key Registration API Call:<br>\nPOST /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption<br>\n{<br>\n\"business_public_key\": \"YOUR_PUBLIC_KEY\"<br>\n}</p>\n<p>Verification:</p>\n<p>Verify your public key is registered using a GET request to the same endpoint<br>\nEnsure the key status is \"active\"</p>\n</div><!--]-->",
  "readme_zh": "# WhatsApp Flows加密数据交换工作流\n\n## 概述\n\n本工作流实现与WhatsApp Flows的安全端到端加密数据交换，用于WhatsApp内部交互式应用。采用WhatsApp商业加密协议，使用RSA进行密钥交换和AES-GCM进行负载加密，在与WhatsApp商业API对接时为敏感数据传输建立安全通道。严格遵循官方WhatsApp商业加密规范，在商户与WhatsApp消费者客户端之间构建基于GraphQL的加密数据交换通道。\n\n## 运作原理\n\n### 加密流程\n\n  1. **Webhook接收** : 接收来自WhatsApp的加密数据包，包含：\n    * `encrypted_flow_data` : AES加密的有效载荷\n    * `encrypted_aes_key` : RSA加密的AES密钥\n    * `initial_vector` : AES解密初始化向量\n  2. **解密过程** :\n    * 使用RSA私钥解密AES密钥\n    * 使用该AES密钥解密有效载荷数据\n    * 反转IV向量用于响应加密\n  3. **数据处理** :\n    * 解析解密后的JSON数据\n    * 根据`screen`参数路由请求\n  4. **响应生成** :\n    * 根据请求类型生成对应响应数据\n    * 使用相同AES密钥和反转IV加密响应\n    * 返回Base64编码的加密响应\n\n### 核心组件\n\n  * **Webhook接入点** : 加密WhatsApp请求的入口\n  * **解密管道** : RSA与AES解密组件\n  * **业务逻辑路由** : 基于屏幕标识的功能路由\n  * **加密管道** : 安全响应加密系统\n\n## 使用指南\n\n  1. **部署工作流** :\n    * 将工作流JSON导入n8n实例\n  2. **配置WhatsApp集成** :\n    * 设置WhatsApp商业API将请求发送至n8n webhook URL\n    * 确保WhatsApp集成使用与本工作流私钥配对的公钥加密数据\n  3. **测试流程** :\n    * 从WhatsApp发送加密测试消息验证连通性\n    * 检查预约数据是否正确获取\n    * 验证座位选择功能是否正常\n  4. **生产环境使用** :\n    * 监控生产环境工作流性能\n    * 按需设置错误通知\n\n## 必备条件\n\n### 认证密钥\nRSA私钥：用于解密AES密钥（已包含在工作流中）  \nWhatsApp商业公钥：需在WhatsApp商业API注册  \nPostgreSQL凭证：用于从数据库获取预约数据\n\n### WhatsApp商业加密设置\n按照WhatsApp商业加密文档要求：\n\n生成2048位RSA密钥对：\n- 私钥由商户保管（用于本工作流）\n- 公钥需与WhatsApp共享\n\n向WhatsApp注册公钥：\n1. 使用WhatsApp云API注册公钥\n2. 通过/v17.0/{WhatsApp商业账户ID}/whatsapp_business_encryption端点设置公钥\n\n密钥注册API调用示例：  \nPOST /v17.0/{WhatsApp-Business-Account-ID}/whatsapp_business_encryption  \n{  \n\"business_public_key\": \"您的公钥\"  \n}\n\n验证步骤：\n1. 通过GET请求至相同端点验证公钥注册状态\n2. 确保密钥状态显示为\"active\"",
  "title_zh": "利用WhatsApp Flows端到端加密打造安全互动应用",
  "publish_date_zh": "最近更新于一天前",
  "workflow_json_zh": "{\n  \"meta\": {\n    \"instanceId\": \"32014bf2061907b54debfd6d86e0e8dc3f3ec9cdd9123c339fc7506178206d83\",\n    \"templateCredsSetupCompleted\": true\n  },\n  \"nodes\": [\n    {\n      \"id\": \"1874c66a-97f0-4a33-a4e9-ab27b950edb4\",\n      \"name\": \"Webhook1\",\n      \"type\": \"n8n-nodes-base.webhook\",\n      \"position\": [\n        -1820,\n        860\n      ],\n      \"webhookId\": \"7116a2e3-c07f-4638-9140-3548a7957d15\",\n      \"parameters\": {\n        \"path\": \"flow\",\n        \"options\": {\n          \"responseHeaders\": {\n            \"entries\": [\n              {\n                \"name\": \"Content-Type\",\n                \"value\": \"text/plain\"\n              }\n            ]\n          }\n        },\n        \"httpMethod\": \"POST\",\n        \"responseMode\": \"responseNode\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"ae85225c-addf-44e8-a60f-f9e0f07a9bc0\",\n      \"name\": \"Json Parser\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1060,\n        860\n      ],\n      \"parameters\": {\n        \"jsCode\": \"function processPayload(items) {\\n  // Create a new array to store the processed items\\n  const processedItems = [];\\n  \\n  // Process each item in the input array\\n  for (const item of items) {\\n    try {\\n      // Extract the decryptedPayload string from the current item\\n      const decryptedPayloadString = item.json.decryptedPayload;\\n      \\n      // Parse the decryptedPayload string into a JavaScript object\\n      const decryptedPayloadObject = JSON.parse(decryptedPayloadString);\\n      \\n      // Extract the date from the data object\\n      const date = decryptedPayloadObject.data.date;\\n      \\n      // Extract the screen value\\n      const screen = decryptedPayloadObject.screen;\\n\\n      // Extract the flow_token object\\n      const flow_token = decryptedPayloadObject.flow_token;\\n      \\n      // Create a new item with the extracted date and screen\\n      const newItem = {\\n        json: {\\n          date: date,\\n          screen: screen,\\n          flow_token: flow_token,\\n          // Optionally preserve original data\\n          originalPayload: item.json\\n        }\\n      };\\n      \\n      // Add the processed item to our array\\n      processedItems.push(newItem);\\n    } catch (error) {\\n      // If there's an error, create an item with error information\\n      processedItems.push({\\n        json: {\\n          error: error.message,\\n          originalItem: item.json\\n        }\\n      });\\n    }\\n  }\\n  \\n  return processedItems;\\n}\\n\\nreturn processPayload(items);\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"8ee86c97-ed4f-48d1-924f-4252e1c07aa5\",\n      \"name\": \"Switch\",\n      \"type\": \"n8n-nodes-base.switch\",\n      \"position\": [\n        -740,\n        860\n      ],\n      \"parameters\": {\n        \"rules\": {\n          \"values\": [\n            {\n              \"conditions\": {\n                \"options\": {\n                  \"version\": 2,\n                  \"leftValue\": \"\",\n                  \"caseSensitive\": true,\n                  \"typeValidation\": \"strict\"\n                },\n                \"combinator\": \"and\",\n                \"conditions\": [\n                  {\n                    \"id\": \"aa929857-8458-49da-a027-0b4d4a7f75f7\",\n                    \"operator\": {\n                      \"type\": \"string\",\n                      \"operation\": \"equals\"\n                    },\n                    \"leftValue\": \"={{ $json.screen }}\",\n                    \"rightValue\": \"APPOINTMENT\"\n                  }\n                ]\n              }\n            },\n            {\n              \"conditions\": {\n                \"options\": {\n                  \"version\": 2,\n                  \"leftValue\": \"\",\n                  \"caseSensitive\": true,\n                  \"typeValidation\": \"strict\"\n                },\n                \"combinator\": \"and\",\n                \"conditions\": [\n                  {\n                    \"id\": \"d83dd890-5ee5-480e-b338-efc5eb26b494\",\n                    \"operator\": {\n                      \"name\": \"filter.operator.equals\",\n                      \"type\": \"string\",\n                      \"operation\": \"equals\"\n                    },\n                    \"leftValue\": \"={{ $json.screen }}\",\n                    \"rightValue\": \"DATE_SELECTION_SCREEN\"\n                  }\n                ]\n              }\n            }\n          ]\n        },\n        \"options\": {}\n      },\n      \"typeVersion\": 3.2\n    },\n    {\n      \"id\": \"76fad406-2591-4531-acab-01cbfcf41c3f\",\n      \"name\": \"Respond to Webhook1\",\n      \"type\": \"n8n-nodes-base.respondToWebhook\",\n      \"position\": [\n        40,\n        760\n      ],\n      \"parameters\": {\n        \"options\": {\n          \"responseCode\": 200\n        },\n        \"respondWith\": \"text\",\n        \"responseBody\": \"={{ $json.body }}\"\n      },\n      \"typeVersion\": 1.1\n    },\n    {\n      \"id\": \"56cb338a-9d7a-4f1a-9c55-5ca9db4f3560\",\n      \"name\": \"Data Extraction Code\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -400,\n        760\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const groupedAppointments = items.reduce((acc, { json: { appointment_date, start_time } }) => {\\n  const dateKey = new Date(appointment_date).toISOString().split('T')[0];\\n  if (!acc[dateKey]) {\\n    acc[dateKey] = [];\\n  }\\n  acc[dateKey].push(start_time);\\n  return acc;\\n}, {});\\n\\nreturn Object.entries(groupedAppointments).map(([date, times]) => ({\\n  json: { appointment_date: date, start_times: times }\\n}));\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"8bd15faf-3a9b-4bb4-ac83-c913a7373480\",\n      \"name\": \"Respond to Webhook2\",\n      \"type\": \"n8n-nodes-base.respondToWebhook\",\n      \"position\": [\n        40,\n        1000\n      ],\n      \"parameters\": {\n        \"options\": {\n          \"responseCode\": 200\n        },\n        \"respondWith\": \"text\",\n        \"responseBody\": \"={{ $json.body }}\"\n      },\n      \"typeVersion\": 1.1\n    },\n    {\n      \"id\": \"67b06ae5-81c1-4efd-993e-a54e36bc5ce7\",\n      \"name\": \"Data Extraction Code1\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -400,\n        1000\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\n// Return the result properly formatted for n8n\\nreturn seats.map(seat => ({ json: { seat } }));\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"2d05f87c-a2c5-4790-9a85-c6cda46db927\",\n      \"name\": \"move to base64\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1600,\n        860\n      ],\n      \"parameters\": {\n        \"jsCode\": \"console.log($json);\\n\\nreturn [\\n  {\\n    encryptedFlowData: Buffer.from($json.body?.encrypted_flow_data || \\\"\\\", \\\"base64\\\"),\\n    encryptedAesKey: Buffer.from($json.body?.encrypted_aes_key || \\\"\\\", \\\"base64\\\"),\\n    initialVector: Buffer.from($json.body?.initial_vector || \\\"\\\", \\\"base64\\\"),\\n  }\\n];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"760536f8-c3f4-4d24-be36-4ac08004eb48\",\n      \"name\": \"Decryption Code\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -1320,\n        860\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const crypto = require(\\\"crypto\\\");\\n\\nconst privateKey = `-----BEGIN PRIVATE KEY-----\\n[INSERT YOUR KEY HERE]\\n-----END PRIVATE KEY-----`;\\n\\n// Convert input buffers\\nconst encryptedAesKeyBuffer = Buffer.from($json.encryptedAesKey.data);\\nconst initialVector = Buffer.from($json.initialVector.data);\\nconst encryptedFlowData = Buffer.from($json.encryptedFlowData.data);\\n\\n// Check if encrypted AES key, IV, and encrypted flow data exist\\nif (!encryptedAesKeyBuffer || !initialVector || !encryptedFlowData) {\\n  throw new Error(\\\"Missing required data (encrypted AES key, IV, or flow data)\\\");\\n}\\n\\n// Decrypt AES key using RSA\\nconst decryptedKey = crypto.privateDecrypt(\\n  {\\n    key: privateKey,\\n    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\\n    oaepHash: \\\"sha256\\\",\\n  },\\n  encryptedAesKeyBuffer\\n);\\n\\n// Ensure AES key is exactly 16 bytes (AES-128 requires it)\\nconst aesKey = decryptedKey.slice(0, 16);\\nif (aesKey.length !== 16) {\\n  throw new Error(\\\"Invalid AES Key length\\\");\\n}\\n\\n// Handle initialization vector (IV): If needed, flip the IV bits (standardize behavior)\\nconst standardizedIv = Buffer.from(initialVector);\\nif (standardizedIv.length !== 16) {\\n  throw new Error(\\\"Invalid IV length, must be 16 bytes\\\");\\n}\\n\\n// Extract the last 16 bytes as the authentication tag (GCM uses 16-byte tags)\\nconst authTag = encryptedFlowData.slice(-16);\\nconst encryptedDataWithoutTag = encryptedFlowData.slice(0, -16);\\n\\n// AES Decryption\\nconst decipher = crypto.createDecipheriv(\\\"aes-128-gcm\\\", aesKey, standardizedIv);\\ndecipher.setAuthTag(authTag);\\n\\nlet decrypted;\\ntry {\\n  decrypted = Buffer.concat([\\n    decipher.update(encryptedDataWithoutTag),\\n    decipher.final(),\\n  ]);\\n} catch (error) {\\n  throw new Error(\\\"Decryption failed: \\\" + error.message);\\n}\\n\\nreturn [{ \\n  decryptedPayload: decrypted.toString(\\\"utf-8\\\"),\\n  aesKey: aesKey.toString(\\\"base64\\\")\\n}];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"17c055f3-c278-48c4-89d4-d305a35bc526\",\n      \"name\": \"Encrypt Return\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -200,\n        760\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const crypto = require(\\\"crypto\\\");\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\n\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\n// Check if 'data' is a property of initialVector\\nconst ivData = initialVector.data || initialVector; // Fallback to initialVector if no 'data' property\\n\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\n// Check for various formats of initialVector\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\n// Invert Initialization Vector\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF)); // Ensure the result stays a valid byte\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\n\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Extract data from the input with proper error handling\\nlet date = \\\"2025-03-14\\\"; // Default fallback date\\nlet startTimes = []; // Default empty array for start times\\n\\n// Check if $json exists and has the expected structure\\nif ($json) {\\n    // Check if $json is an array\\n    if (Array.isArray($json) && $json.length > 0) {\\n        const appointmentData = $json[0];\\n        if (appointmentData && appointmentData.appointment_date) {\\n            date = appointmentData.appointment_date;\\n        }\\n        if (appointmentData && Array.isArray(appointmentData.start_times)) {\\n            startTimes = appointmentData.start_times;\\n        }\\n    } else if ($json.appointment_date) {\\n        // If $json is not an array but has appointment_date directly\\n        date = $json.appointment_date;\\n        if (Array.isArray($json.start_times)) {\\n            startTimes = $json.start_times;\\n        }\\n    }\\n}\\n\\n// Log the structure of $json for debugging\\nconsole.log(\\\"Input JSON structure:\\\", JSON.stringify($json, null, 2));\\n\\n// Ensure we have time slots (use defaults if none found)\\nif (!startTimes.length) {\\n    console.log(\\\"No time slots found in input, using defaults\\\");\\n    startTimes = [\\\"12:00:00\\\", \\\"12:30:00\\\", \\\"13:30:00\\\", \\\"14:00:00\\\"];\\n}\\n\\n// Map the time slots to the required format\\nconst timeSlots = startTimes.map((timeString, index) => ({\\n    id: `time_${index + 1}`,\\n    title: timeString\\n}));\\n\\n// Map the date slots for each time slot\\nconst dateSlots = [{\\n    id: \\\"date_1\\\",\\n    title: date\\n}];\\n\\n// Define the response data with the extracted time and date\\nconst responseData = {\\n    status: \\\"active\\\",\\n    time: timeSlots,\\n    date: dateSlots\\n};\\n\\n// Define the flow_token (accessed from the correct path)\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\"; // Fetch the flow_token dynamically from the path\\n\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\n// Define the next screen (this should be based on your flow logic)\\nconst nextScreen = \\\"APPOINTMENT\\\"; // You can set this dynamically depending on the flow\\n\\n// Define Response Message (updated to match the required response format)\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\", // Fixed version as per your requirements\\n    action: \\\"data_exchange\\\", // Since we're responding to a data exchange request\\n    screen: nextScreen, // The next screen that the user will be redirected to\\n    data: responseData, // Data to send back (includes the time and date)\\n    flow_token: flowToken, // Flow token for session identification\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\n// Get the authentication tag\\nconst authTag = cipher.getAuthTag();\\n\\n// Append the authentication tag to the encrypted response\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\n\\n// Encode the entire response as Base64\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the Base64-encoded response as the body\\nreturn [{ body: base64Response }];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"412f55e3-5867-4e65-a494-3e3bf991d59c\",\n      \"name\": \"Encrypt Return1\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"position\": [\n        -200,\n        1000\n      ],\n      \"parameters\": {\n        \"jsCode\": \"const crypto = require(\\\"crypto\\\");\\n\\nconst jsonData = items;\\n\\n// Parse the decryptedPayload string into a JSON object\\nconst decryptedPayload = JSON.parse(jsonData[0].json.originalPayload.decryptedPayload);\\n\\n// Extract the seats array\\nconst seats = decryptedPayload.data.seats;\\n\\nif (!seats || !Array.isArray(seats) || seats.length === 0) {\\n    throw new Error(\\\"Seats data is missing or invalid.\\\");\\n}\\n\\n// Access initial_vector from the correct path\\nconst initialVector = $('move to base64').first().json.initialVector;\\nif (!initialVector) {\\n    throw new Error(\\\"Initial Vector is undefined or missing.\\\");\\n}\\n\\nconst ivData = initialVector.data || initialVector;\\nif (!ivData) {\\n    throw new Error(\\\"Initial Vector 'data' is undefined or missing.\\\");\\n}\\n\\nlet ivBuffer;\\nif (typeof ivData === \\\"string\\\") {\\n    ivBuffer = Buffer.from(ivData, 'base64');\\n} else if (Buffer.isBuffer(ivData)) {\\n    ivBuffer = ivData;\\n} else if (Array.isArray(ivData)) {\\n    ivBuffer = Buffer.from(ivData);\\n} else {\\n    throw new Error(\\\"Initial Vector 'data' is in an unsupported format.\\\");\\n}\\n\\nconst invertedIV = Buffer.from(ivBuffer.map((b) => ~b & 0xFF));\\n\\n// Access AES Key from the correct path\\nconst aesKeyBase64 = $('Decryption Code').first().json.aesKey || \\\"\\\";\\nif (!aesKeyBase64) {\\n    throw new Error(\\\"AES Key is missing.\\\");\\n}\\nconst aesKey = Buffer.from(aesKeyBase64, \\\"base64\\\");\\n\\n// Define the response data with the extracted seats\\nconst responseData = {\\n    status: \\\"active\\\",\\n    seats: seats.map((seat, index) => ({\\n        id: `seat_${index + 1}`,\\n        title: seat\\n    }))\\n};\\n\\n// Define the flow_token\\nconst flowToken = $('Json Parser').first().json.flow_token || \\\"\\\";\\nif (!flowToken) {\\n    throw new Error(\\\"Flow token is missing.\\\");\\n}\\n\\nconst nextScreen = \\\"SUMMARY\\\";\\n\\nconst responseMessage = JSON.stringify({\\n    version: \\\"3.0\\\",\\n    action: \\\"data_exchange\\\",\\n    screen: nextScreen,\\n    data: responseData,\\n    flow_token: flowToken,\\n});\\n\\n// Encrypt Response using AES-GCM\\nconst cipher = crypto.createCipheriv(\\\"aes-128-gcm\\\", aesKey, invertedIV);\\nlet encryptedResponse = Buffer.concat([\\n    cipher.update(responseMessage, \\\"utf-8\\\"),\\n    cipher.final()\\n]);\\n\\nconst authTag = cipher.getAuthTag();\\nconst result = Buffer.concat([encryptedResponse, authTag]);\\nconst base64Response = result.toString(\\\"base64\\\");\\n\\n// Return the encrypted response\\nreturn [{ body: base64Response }];\\n\"\n      },\n      \"typeVersion\": 2\n    },\n    {\n      \"id\": \"6c130dfe-bec9-4ca5-af1a-9b55ed593b84\",\n      \"name\": \"Sticky Note\",\n      \"type\": \"n8n-nodes-base.stickyNote\",\n      \"position\": [\n        -2480,\n        140\n      ],\n      \"parameters\": {\n        \"width\": 580,\n        \"height\": 1900,\n        \"content\": \"## 试用流程\\n\\n### 🔗 **1. Webhook入口与初始解密模块**\\n\\n**涉及节点:**\\n* `Webhook1`\\n* `转为base64`\\n* `[部分可见的RSA+AES解密节点]`\\n\\n**说明:**\\n流程始于监听HTTP POST请求的`Webhook1`节点，这些请求通常包含需要解码的加密数据。收到数据后，`转为base64`节点将加密组件(`encrypted_flow_data`, `encrypted_aes_key`, `initial_vector`)重新格式化为二进制缓冲区，作为解密必需输入。\\n\\n随后（截图中未完整显示）的JavaScript代码会使用RSA私钥解密AES密钥，进而解密实际数据载荷（可能采用AES-GCM算法）。这是典型的安全混合加密方案——RSA用于密钥交换，AES用于数据加密。\\n\\n---\\n\\n### 🧠 **2. 载荷解析与预处理模块**\\n\\n**涉及节点:**\\n* `JSON解析器`\\n\\n**说明:**\\n此模块对Whatsapp Flows解密后的JSON载荷进行解析，提取关键元素，在根据用户交互决定后续逻辑或响应前实现输入标准化。\\n\\n---\\n\\n### 🔀 **3. 流程决策模块**\\n\\n**涉及节点:**\\n* `条件分支`\\n\\n**说明:**\\n该决策节点根据先前提取的屏幕上下文路由工作流。例如当用户处于预约日期界面时：\\n* `\\\"APPOINTMENT\\\"` → 执行预约数据处理逻辑\\n实现用户旅程不同步骤间的动态路由适配。\\n\\n---\\n\\n### 📆 **4. 预约数据处理模块**\\n\\n**涉及节点:**\\n* `数据提取代码`\\n* `响应Webhook1`\\n\\n**说明:**\\n当屏幕类型为`\\\"APPOINTMENT\\\"`时，`数据提取代码`节点会处理预约数据（通常按日期分组预约时段），可用于生成日历视图展示可选时间。\\n\\n处理结果通过`响应Webhook1`以纯文本形式返回，确保Whatsapp Flows端到端的安全交互闭环。\\n\\n### 🧩 **流程概览**\\n\\n该n8n工作流处理加密用户交互，并根据当前所处界面动态适配，通用模式如下：\\n1. **Webhook接收加密数据**\\n2. **采用RSA-AES混合加密进行解密**\\n3. **解析获取当前步骤(`screen`)信息**\\n4. **条件逻辑决定执行路径**\\n5. **提取关键信息（如预约数据）**\\n6. **将响应返回用户界面/聊天机器人**\"\n      },\n      \"typeVersion\": 1\n    }\n  ],\n  \"pinData\": {\n    \"Webhook1\": [\n      {\n        \"body\": {\n          \"initial_vector\": \"PFfPS7sPwJqYWLySIGWF/Q==\",\n          \"encrypted_aes_key\": \"A2BJ/NRN0WsSHZ8KeH1mUreTHICGMprbvh8BP7vEAIyIxeADgtYODJNkJ5P77WsAtJkIx8BwibiWlPfdJlBFaYeQx86hllirf4GygagECsgEJyNX0B98rpx/0eic4FqdR/8bqDWNFZbi7i78vMDG4x+9PArJIwkXWtzuLaLtM2J5j/SAx2y3PV5pKeYqcfg7w/uYlubmkKZjJYuSLmIOHbdO5mmvblDBm8ap5COVvEzK18K3VYyT8BVzawUgfxxhlyCBd7bB36vcS8iKkTl6EFgkPqFmpcCOmZNSmnsJ5tu+e7uRX8OgwryqbFNfb/plZGUPTQJZlrObFO8rw22yJQ==\",\n          \"encrypted_flow_data\": \"tkGedq3MER+FadPJh3W6amE18m0x1Xzge6cqPeb5sNkBgOfTtHkRrHuuLjrLG+MvOd9oSzFXdx4sT90cliJSLfp0uUBtVCnBT33Qa5PF87E/iNRtyOCW4Jcp1yv1po54jSVWnVjhgZRCt9akyjBYK1v2YJW5qxarsvFDFsZMsEOOMMOLtOWHGgGGS+tKR5PB7X4WwMHrlCLG9j0yT1U=\"\n        },\n        \"query\": {},\n        \"params\": {},\n        \"headers\": {\n          \"host\": \"n8n.doubleit.com.br\",\n          \"accept\": \"*/*\",\n          \"connection\": \"upgrade\",\n          \"user-agent\": \"facebookexternalua\",\n          \"content-type\": \"application/json\",\n          \"content-length\": \"657\",\n          \"accept-encoding\": \"deflate, gzip\",\n          \"x-hub-signature\": \"sha256=8e8d012f89e53d0a67aa31c19b472636e55b2e86e1569af9b200eb65839a39ce\",\n          \"x-hub-signature-256\": \"sha256=5deea4ea13d95f1da43be49579528f5928e29cb7772abd2455d319ff7396df4e\"\n        },\n        \"webhookUrl\": \"https://n8n.doubleit.com.br/webhook/flow\",\n        \"executionMode\": \"production\"\n      }\n    ]\n  },\n  \"connections\": {\n    \"Switch\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Data Extraction Code\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ],\n        [\n          {\n            \"node\": \"Data Extraction Code1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Webhook1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"move to base64\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Json Parser\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Switch\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Encrypt Return\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Respond to Webhook1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"move to base64\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Decryption Code\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Decryption Code\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Json Parser\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Encrypt Return1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Respond to Webhook2\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Data Extraction Code\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Encrypt Return\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Data Extraction Code1\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Encrypt Return1\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}"
}