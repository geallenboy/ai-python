{
  "url": "https://blog.n8n.io/the-good-the-bad-and-the-ugly-of-looping-with-n8n/",
  "title": "The Good, the Bad, and the Ugly of looping with n8n",
  "excerpt": "If you are a developer and you already have a good handle on loops, this text will help you map your existing programming knowledge to n8n concepts.",
  "thumbnail": "https://blog.n8n.io/content/images/size/w1200/2023/05/Slide-16_9---26--1-.png",
  "tags": [
    "News"
  ],
  "html": "<p>This post will cover three possible approaches to creating loops in n8n by building a web scraping workflow with paging support. With these three examples under your belt, you will better understand how looping can be used to our advantage when solving repetitive problems in n8n.</p><p>We will also cover a bit of n8n internals that can come in handy in any n8n workflow, looped or not.</p><p>If you are a developer and you already have a good handle on loops, this text will hopefully help you map your existing programming knowledge to n8n concepts. </p><h2 id=\"what-is-looping-when-and-how-to-use-it\">What is looping, when and how to use it?</h2><p>Before you jump on a chat with your favorite AI chatbot with the same question, let's clarify here what we consider looping in the context of n8n workflow and what are some use cases where we can take advantage of such a mechanism.</p><p><a href=\"https://docs.n8n.io/flow-logic/looping/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">Looping in n8n</a> is a way of creating workflows so <strong>data flow (embodied in n8n connection lines) goes through one or more nodes multiple times.</strong> Each loop execution is called an <em>iteration</em> or a <em>step</em>, so we'll use these terms interchangeably throughout this post.</p><p>At the start of your journey to becoming an n8n hero, it's easy to think of workflows as one-way streams which take our input data, manipulate it and spit out some results. But imagine a scenario where we must employ a set of nodes to do a particular task multiple times. If it's just a few nodes that need to be run a couple of times, our first hunch would be to copy them after the original set and be done with it. On the other hand, copying and pasting the same 15 nodes tens of times is probably not the most efficient way to build workflows (not to mention a case where you cannot know the number of iterations in advance).</p><p>That's where loops come in.</p><p><strong>Creating loops in our workflow enables us to reuse a set of nodes multiple times with different input data each time they are executed</strong>. Before going any further with the theory, in case you still haven't got a clear picture in your head, this is what a simple (one-node) loop looks like in the n8n workflow:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/1_loop_example.png\" class=\"kg-image lightense-target\" alt=\"A simple loop\" loading=\"lazy\" width=\"398\" height=\"375\"><figcaption><em>A simple loop</em></figcaption></figure><p>Here are some examples of workflows where looping is the best tool for the given task:</p><ul><li>Scraping web pages that use pagination to display all items,</li><li>Implementing process with a maximum number of retries (like user login or checking if an API server is online),</li><li>Generating patterns or sequences (e.g., custom slack message for each user in a Google Sheet),</li><li>Finding a particular element (like an email with a specific subject) of a list (the inbox).</li></ul><p>As mentioned in the introduction, we will solve the problem of scraping a paginated web page in this post, but before we get our hands dirty, let's take a look at the anatomy of a loop:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/2_loop_anatomy.png\" class=\"kg-image lightense-target\" alt=\"Anatomy of a loop\" loading=\"lazy\" width=\"1477\" height=\"601\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/2_loop_anatomy.png 600w, https://blog.n8n.io/content/images/size/w1000/2023/05/2_loop_anatomy.png 1000w, https://blog.n8n.io/content/images/2023/05/2_loop_anatomy.png 1477w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>Anatomy of a loop</em></figcaption></figure><p>The image above shows the most critical steps in each loop, but as will be shown in scraping implementation, the order and performance of each of those steps can vary based on the use case.</p><p>Anyhow, here are the main elements of a loop:</p><ul><li>Input data: We can see each loop as a separate mini-workflow with inputs and outputs. <strong>The main difference here is that loops usually feed the modified information back to the start of the loop, making each iteration work with different data</strong>. This last part is where the magic of looping happens since going over the same set of nodes with the same input each time is rarely helpful.</li><li>Loop logic: This is the set of nodes that performs tasks in each iteration.</li><li>Loop condition: When creating a looping flow, we must decide which rules determine if our loop will start a new step or stop looping and continue with the rest of the workflow. We must check these conditions in each iteration to avoid endless loops, making our workflow run indefinitely and likely crash our n8n instance.</li></ul><h2 id=\"task-description-building-a-web-scraping-workflow-with-paging-support\">Task description: building a web scraping workflow with paging support</h2><p>Our web scraping workflow will use an <a href=\"https://webscraper.io/test-sites/e-commerce/static/phones/touch?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">example page</a> from <a href=\"http://www.webscraper.io/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">www.webscraper.io</a> as a safe playground for the demonstration.</p><p>By looking at the first page of this webshop, we can see that it shows only a portion of all products, so to get all of them, our workflow needs to scrape data from each page, one by one. Since all pages have the same structure, we can use the same set of n8n nodes to extract the data and create a loop to run that set for each product page. </p><p>Currently, there are only two pages in the shop, but since we cannot rely on that being always the case (products come and go in webshops constantly), our workflow will also need to detect if there are more pages to scrape before starting a new iteration. We will discuss each of those problems in greater detail as we build our workflows and move on to making stuff with n8n.</p><p>If you want to build upon this experience and start scraping data from a real-world website, please ensure that website authors enable scrapping and read <a href=\"https://blog.n8n.io/how-to-scrape-data-from-a-website/\">web scrapping best practices</a> post on our blog.</p><h2 id=\"the-ugly-using-nodes-to-implement-looping\">The Ugly: Using nodes to implement looping</h2><p>In the first approach to web scraping using n8n, we will manually build and maintain all our looping logic using <a href=\"https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.set/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\"><em>Set</em> nodes</a>. Before we dissect each node individually, here's what the complete workflow looks like:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/8_the_ugly.png\" class=\"kg-image lightense-target\" alt=\"Workflow 1: The Ugly\" loading=\"lazy\" width=\"2000\" height=\"669\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/8_the_ugly.png 600w, https://blog.n8n.io/content/images/size/w1000/2023/05/8_the_ugly.png 1000w, https://blog.n8n.io/content/images/size/w1600/2023/05/8_the_ugly.png 1600w, https://blog.n8n.io/content/images/size/w2400/2023/05/8_the_ugly.png 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Workflow 1: The Ugly</figcaption></figure><p>Our workflow starts with <a href=\"https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.manualworkflowtrigger/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">a <em>Manual Trigger</em> node</a> followed by a <em>Set</em> node that sets the page number to 1. This number will be used as an input for <a href=\"https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.httprequest/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">the <em>HTTP</em> node</a> and will change as we progress through subsequent pages.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/3_ugly-set_node-1.png\" class=\"kg-image lightense-target\" alt=\"Set Node\" loading=\"lazy\" width=\"698\" height=\"555\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/3_ugly-set_node-1.png 600w, https://blog.n8n.io/content/images/2023/05/3_ugly-set_node-1.png 698w\"><figcaption><em>Set Node</em></figcaption></figure><p>The meat of this process is fetching and processing (scraping) each page, which is implemented using the <em>HTTP Request</em> and the <em>HTML</em> nodes. To get the first product page, we need to add an <em>HTTP Request</em> node configured to send a GET request to the following URL (remember to use expression mode when specifying URL so the correct page number is used instead of a variable):</p><!--kg-card-begin: markdown--><p><code>https://webscraper.io/test-sites/e-commerce/static/phones/touch?page={{ $json.page }}</code></p>\n<!--kg-card-end: markdown--><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/4_ugly-http_node.png\" class=\"kg-image lightense-target\" alt=\"HTTP Request Node\" loading=\"lazy\" width=\"722\" height=\"639\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/4_ugly-http_node.png 600w, https://blog.n8n.io/content/images/2023/05/4_ugly-http_node.png 722w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>HTTP Request Node</em></figcaption></figure><p>After that, we can add an <em>HTML</em> node and set it up to extract (so choose <em>Extract HTML Content</em> as an action when adding the node) the following data from the web page:</p><ol><li>Each product details. For simplicity's sake, we will only extract the product name,</li><li>Current page. We will use this to move on to the current page in the shop.</li></ol><p>We can set this node to return this data in <em><strong>products</strong></em> and <em><strong>currentPage</strong></em> properties, respectively, by configuring it the following way:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/5_ugly-html_node.png\" class=\"kg-image lightense-target\" alt=\"HTML Node\" loading=\"lazy\" width=\"788\" height=\"987\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/5_ugly-html_node.png 600w, https://blog.n8n.io/content/images/2023/05/5_ugly-html_node.png 788w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>HTML Node</em></figcaption></figure><p>With this in place, we have our loop input data and logic, and it's time to add the condition before we create the actual looping connection.</p><p>Looking at each product page, we can see that the full list displays exactly six products while the last one contains fewer. We can use that knowledge to check if we are on the last page by testing the number of products scraped on each of them. We will assume that the first page with fewer than six products is the last in the shop. There are more robust ways of detecting the last page, but this method will enable us to implement our paging without juggling more data in additional nodes.</p><p>We will impose our loop condition by adding an IF node before our connection loops back to the input of the <em>HTTP Request</em> node. This <em>IF</em> node has one <em>Number</em> condition which checks if <em><strong>{{ $json.products.length }}</strong></em> is smaller than the number 6:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/6_ugly-if_node.png\" class=\"kg-image lightense-target\" alt=\"IF Node\" loading=\"lazy\" width=\"722\" height=\"488\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/6_ugly-if_node.png 600w, https://blog.n8n.io/content/images/2023/05/6_ugly-if_node.png 722w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>IF Node</em></figcaption></figure><p>If this is not the case, we need to proceed with scraping the next page, which we will do by connecting a <em><strong>false</strong></em> output branch of the <em>IF</em> node to a new <em>Set</em> node, increasing the page number by one, and looping it back to our <em>HTTP Request</em> node.</p><p>The following image shows this new <em>Set</em> node and its parameter values:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/7_ugly-set_node.png\" class=\"kg-image lightense-target\" alt=\"Set Node\" loading=\"lazy\" width=\"730\" height=\"529\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/7_ugly-set_node.png 600w, https://blog.n8n.io/content/images/2023/05/7_ugly-set_node.png 730w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>Set Node</em></figcaption></figure><p>Congrats! You just created a loop in n8n!</p><p>Now, this workflow's job is done when our condition from the <em>IF</em> node resolves as <em><strong>true</strong></em>. We won't go into details of what should happen then, but you'll notice that the complete workflow has a <em>Code</em> node at the end, which uses a bit of n8n trickery to get the list of all scrapped products (a bit more on that at the end of this post).</p><h2 id=\"the-bad-utilizing-workflow-static-data\">The Bad: Utilizing workflow static data</h2><p>The loop implemented in this example is very similar to the previous one, with two significant differences:</p><ol><li>Instead of parsing the current page number from the scrapped web page, we will store it in our <a href=\"https://docs.n8n.io/code-examples/methods-variables-examples/get-workflow-static-data/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">workflow static data</a>. You can think about the workflow static data as a secret storage inside each workflow which can be accessed from within your <em>Code</em> nodes and expressions, and it enables us to store, read, and update values (numbers, strings, dates, etc.) that are of interest for the current workflow. This will provide access to the stored data directly in the nodes that need it instead of unnecessarily passing the values around the workflow.</li><li>We will use pagination HTML elements to determine the number of pages that need to be scrapped and to check if we have reached the last page. This will ensure our scraping algorithm works in case the last page contains the same number of products as the rest.</li></ol><p>Here's what this workflow looks like after everything is put together:<br></p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/12_the_bad.png\" class=\"kg-image lightense-target\" alt=\"Workflow 2: The Bad\" loading=\"lazy\" width=\"2000\" height=\"640\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/12_the_bad.png 600w, https://blog.n8n.io/content/images/size/w1000/2023/05/12_the_bad.png 1000w, https://blog.n8n.io/content/images/size/w1600/2023/05/12_the_bad.png 1600w, https://blog.n8n.io/content/images/size/w2400/2023/05/12_the_bad.png 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em><em>Workflow 2: The Bad</em></em></figcaption></figure><p>A possible downside is that it relies on coding more than the previous one, but, as will be shown, it requires only a few lines of JavaScript to get everything running. Most nodes are the same as in the first example, so we won't go into the weeds when going over this method.</p><p>We start our workflow with a <em>Code</em> node, set to run once for all items and containing the following piece of code (don't forget to add a trigger node as a first step!):</p><!--kg-card-begin: markdown--><pre><code>const workflowStaticData = $getWorkflowStaticData('global');\nlet currentPage = workflowStaticData.currentPage;\n\nif (currentPage) {\n  currentPage = currentPage + 1;\n} else {\n  currentPage = 1;\n}\nreturn {\n json: {\n   page: currentPage,\n }\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>If you are not so fluent in JavaScript, here's the translation: it tries to get the <em><strong>pageNumber</strong></em> value from the <em><strong>global</strong></em> workflow static data store and, if it's found, increments it by one (which moves to scrape the following product page). If there is no such value, which is the case when the workflow runs for the first time, it will set it to 1.</p><p>The next step is to fetch the current product page using the <em>HTTP Request</em> node. We can accomplish this by setting this node up exactly as we did in the first example:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/9_bad-http_node.png\" class=\"kg-image lightense-target\" alt=\"HTTP Request Node\" loading=\"lazy\" width=\"723\" height=\"630\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/9_bad-http_node.png 600w, https://blog.n8n.io/content/images/2023/05/9_bad-http_node.png 723w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>HTTP Request Node</em></figcaption></figure><p>Moving on, we again need the <em>HTML</em> node to extract the data we need from each product page. As mentioned, we want to parse out our current page, the total number of pages, and each product's data. So, in this case, our <em>HTML</em> node is set up the following way:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/10_bad-html_node.png\" class=\"kg-image lightense-target\" alt=\"HTML Node\" loading=\"lazy\" width=\"784\" height=\"1259\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/10_bad-html_node.png 600w, https://blog.n8n.io/content/images/2023/05/10_bad-html_node.png 784w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>HTML Node</em></figcaption></figure><p>Once we have processed the product page, it's time to decide if we need to repeat the process for the next page or if it reached the last page. This time, we have both the current page number and the total page count, so this boils down to adding an <em>IF</em> node that compares the two:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/11_bad-if_node.png\" class=\"kg-image lightense-target\" alt=\"IF Node\" loading=\"lazy\" width=\"716\" height=\"451\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/11_bad-if_node.png 600w, https://blog.n8n.io/content/images/2023/05/11_bad-if_node.png 716w\"><figcaption><em>IF Node</em></figcaption></figure><p>Notice that we are subtracting number 2 from the pagination element count since the first and last pagination elements are used to jump to the list's beginning and end and are not individual page links. After this, if we still are not on the last page, we store the current page number inside our workflow static data store using the new <em>Code</em> node:</p><!--kg-card-begin: markdown--><pre><code>const workflowStaticData = $getWorkflowStaticData('global');\nworkflowStaticData.currentPage = parseInt($input.first().json.currentPage);\nreturn {}\n</code></pre>\n<!--kg-card-end: markdown--><p>And finally, it's time to connect this new <em>Code</em> node back to the first one we created earlier, which will increment the stored number and start the scrapping process for the next page.</p><h2 id=\"the-good-leveraging-runtime-data-to-keep-track-of-iterations\">The Good: Leveraging runtime data to keep track of iterations</h2><p>Still around? Good.</p><p>It's time for the last and most streamlined approach to implement looping in n8n. Here, we will take advantage of a little n8n internal mechanism to keep track of the product page we are currently on.</p><p>As usual, the entire workflow is shown below, where you can see the nice clean loop it makes:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/15_the_good.png\" class=\"kg-image lightense-target\" alt=\"Workflow 3: The Good\" loading=\"lazy\" width=\"2000\" height=\"441\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/15_the_good.png 600w, https://blog.n8n.io/content/images/size/w1000/2023/05/15_the_good.png 1000w, https://blog.n8n.io/content/images/size/w1600/2023/05/15_the_good.png 1600w, https://blog.n8n.io/content/images/size/w2400/2023/05/15_the_good.png 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>Workflow 3: The Good</em></figcaption></figure><p>When observing workflows as they execute, you may have noticed a small number appearing in each node's bottom-right corner as they are run. That number is called the node's run index and counts the time the node executes within the current workflow execution. Exactly what we need for our page counting!</p><p>On top of that, run indexes are available to use in expressions with the special <em><strong>$runIndex</strong></em> keyword. With this in mind, we can construct a workflow very similar to the one from the previous example, but now we can use the run index as a current page number and get rid of both <em>Code</em> nodes.</p><p>As the first step, we will use a <em>Set</em> node that outputs one value (called page) which is a run index incremented by one (this is needed since run indexes start with zero in n8n):</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/13_good-set_node.png\" class=\"kg-image lightense-target\" alt=\"Set Node\" loading=\"lazy\" width=\"726\" height=\"530\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/13_good-set_node.png 600w, https://blog.n8n.io/content/images/2023/05/13_good-set_node.png 726w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>Set Node</em></figcaption></figure><p>After this, <em>HTTP Request</em> and <em>HTML</em> Nodes are the same as in the example before, with the difference that we don't need to scrape the current page in the <em>HTML</em> node (just products and pagination elements):</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/14_good-html_node.png\" class=\"kg-image lightense-target\" alt=\"HTML Node\" loading=\"lazy\" width=\"790\" height=\"993\" srcset=\"https://blog.n8n.io/content/images/size/w600/2023/05/14_good-html_node.png 600w, https://blog.n8n.io/content/images/2023/05/14_good-html_node.png 790w\" sizes=\"(min-width: 720px) 720px\"><figcaption><em>HTML Node</em></figcaption></figure><p>After the <em>HTML</em> node, we will add our trusty <em>IF</em> node to check if we are on the last page. We will test if the current page number <em><strong>($runIndex)</strong> </em>is smaller than the total product page count <em><strong>($json.pagination.length - 2)</strong></em>. If this is true, we will create our loop by connecting the <em><strong>true</strong></em> output branch from our <em>IF</em> node back to the input of the <em>Set</em> node. That's it. No nodes in between are needed!</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://blog.n8n.io/content/images/2023/05/16_good_if_node.png\" class=\"kg-image lightense-target\" alt=\"IF Node\" loading=\"lazy\" width=\"561\" height=\"511\"><figcaption><em>IF Node</em></figcaption></figure><p>And one last trick for the end. Now that you have processed all the pages, we can only see the data from the last page in our workflow input. But fear not; the cool thing about n8n is that we can access each node's data from every iteration it runs. This is exactly what the <em>List all products</em> node that you saw in complete workflows is doing. Here's the code it contains:</p><!--kg-card-begin: markdown--><pre><code>let pageCount = $node['Scrape data from the page'].runIndex;\nlet allProducts = [];\n\nfor (let index = 0; index &lt;= pageCount; index++) {\n  allProducts = allProducts.concat($items('Scrape data from the page', 0, index));\n};\n\nreturn allProducts;\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"wrap-up\">Wrap up</h2><p>In this post, we covered three ways of creating loops in n8n workflow to scrape data from a website:</p><ol><li>By creating and maintaining loop data using <em>Set</em> nodes,</li><li>By making use of workflow static data and</li><li>By utilizing the node's run index to keep track of loop iterations.</li></ol><p>These are not the only approaches to creating loops in n8n but will serve as good guidelines for solving your future automation problems that require looping. Also, we looked at some advanced n8n techniques and internals that, we hope, will come in handy in your prospective n8n journey.<br></p><p>Register your <a href=\"https://n8n.io/cloud/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">n8n account in the cloud</a> and start automating for free. You can also <a href=\"https://docs.n8n.io/hosting/?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">run n8n on your server</a> or <a href=\"https://app.n8n.cloud/register?ref=blog.n8n.io\" target=\"_blank\" rel=\"noopener\">download it on your computer</a>!</p><p><br></p><p><br></p><p><br></p>\n\t\t<div class=\"newsletter-banner\">\n\t    <div class=\"newsletter-banner-content\">\n\t      <div class=\"section-header\">\n\t        <h2>Subscribe to <span>n8n newsletter</span></h2>\n\t        <div class=\"section-subheader--bottom\">\n\t          Get the best, coolest, and latest in automation and low-code delivered to your inbox each week.\n\t        </div>\n\t      </div>\n\t      <div class=\"newsletter-banner-form\">\n\t        <form autocomplete=\"off\" class=\"contact-form\" onsubmit=\"subscribeNewsletter(event)\">\n\t        \t<div id=\"recaptcha\" class=\"g-recaptcha\" data-sitekey=\"6LeAQeopAAAAAKlLsRb1weWm6T_vijoQBkGkbHzB\" data-callback=\"submitSubscription\" data-size=\"invisible\"><div class=\"grecaptcha-badge\" data-style=\"bottomright\" style=\"width: 256px; height: 60px; display: block; transition: right 0.3s ease 0s; position: fixed; bottom: 14px; right: -186px; box-shadow: gray 0px 0px 5px; border-radius: 2px; overflow: hidden;\"><div class=\"grecaptcha-logo\"><iframe title=\"reCAPTCHA\" width=\"256\" height=\"60\" role=\"presentation\" name=\"a-x399t7ntvir4\" frameborder=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation allow-modals allow-popups-to-escape-sandbox allow-storage-access-by-user-activation\" src=\"https://www.google.com/recaptcha/api2/anchor?ar=1&amp;k=6LeAQeopAAAAAKlLsRb1weWm6T_vijoQBkGkbHzB&amp;co=aHR0cHM6Ly9ibG9nLm44bi5pbzo0NDM.&amp;hl=en&amp;v=jt8Oh2-Ue1u7nEbJQUIdocyd&amp;size=invisible&amp;cb=n7hiq1hcetut\"></iframe></div><div class=\"grecaptcha-error\"></div><textarea id=\"g-recaptcha-response\" name=\"g-recaptcha-response\" class=\"g-recaptcha-response\" style=\"width: 250px; height: 40px; border: 1px solid rgb(193, 193, 193); margin: 10px 25px; padding: 0px; resize: none; display: none;\"></textarea></div><iframe style=\"display: none;\"></iframe></div>\n\t          <div class=\"input-wrapper\">\n\t            <input placeholder=\"Email\" name=\"email\" type=\"email\" required=\"required\" class=\"\">\n\t            <div class=\"messages\">\n\t              <div class=\"message message--error\">Something went wrong. Please try again later.</div>\n\t              <div class=\"message message--success\">Subscribed!</div>\n\t            </div>\n\t          </div>\n\t          <button type=\"submit\" class=\"submit-btn\">Subscribe</button>\n\t        </form>\n\t      </div>\n\t    </div>\n    </div>\n\t\t<div class=\"post-share-section\">\n\t<div class=\"post-share-wrap\">\n\t\t<a href=\"https://twitter.com/intent/tweet?text=The%20Good%2C%20the%20Bad%2C%20and%20the%20Ugly%20of%20looping%20with%20n8n&amp;url=https://blog.n8n.io/the-good-the-bad-and-the-ugly-of-looping-with-n8n/\" target=\"_blank\" rel=\"noopener\" aria-label=\"Twitter share icon\"><svg role=\"img\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M23.954 4.569c-.885.389-1.83.654-2.825.775 1.014-.611 1.794-1.574 2.163-2.723-.951.555-2.005.959-3.127 1.184-.896-.959-2.173-1.559-3.591-1.559-2.717 0-4.92 2.203-4.92 4.917 0 .39.045.765.127 1.124C7.691 8.094 4.066 6.13 1.64 3.161c-.427.722-.666 1.561-.666 2.475 0 1.71.87 3.213 2.188 4.096-.807-.026-1.566-.248-2.228-.616v.061c0 2.385 1.693 4.374 3.946 4.827-.413.111-.849.171-1.296.171-.314 0-.615-.03-.916-.086.631 1.953 2.445 3.377 4.604 3.417-1.68 1.319-3.809 2.105-6.102 2.105-.39 0-.779-.023-1.17-.067 2.189 1.394 4.768 2.209 7.557 2.209 9.054 0 13.999-7.496 13.999-13.986 0-.209 0-.42-.015-.63.961-.689 1.8-1.56 2.46-2.548l-.047-.02z\"></path></svg></a>\n\t\t<a href=\"https://www.facebook.com/sharer/sharer.php?u=https://blog.n8n.io/the-good-the-bad-and-the-ugly-of-looping-with-n8n/\" target=\"_blank\" rel=\"noopener\" aria-label=\"Facebook share icon\"><svg role=\"img\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M23.9981 11.9991C23.9981 5.37216 18.626 0 11.9991 0C5.37216 0 0 5.37216 0 11.9991C0 17.9882 4.38789 22.9522 10.1242 23.8524V15.4676H7.07758V11.9991H10.1242V9.35553C10.1242 6.34826 11.9156 4.68714 14.6564 4.68714C15.9692 4.68714 17.3424 4.92149 17.3424 4.92149V7.87439H15.8294C14.3388 7.87439 13.8739 8.79933 13.8739 9.74824V11.9991H17.2018L16.6698 15.4676H13.8739V23.8524C19.6103 22.9522 23.9981 17.9882 23.9981 11.9991Z\"></path></svg></a>\n\t\t<!-- <a href=\"javascript:\" class=\"post-share-link\" id=\"copy\" data-clipboard-target=\"#copy-link\" aria-label=\"Copy link icon\"><svg role=\"img\" viewBox=\"0 0 33 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27.3999996,13.4004128 L21.7999996,13.4004128 L21.7999996,19 L18.9999996,19 L18.9999996,13.4004128 L13.3999996,13.4004128 L13.3999996,10.6006192 L18.9999996,10.6006192 L18.9999996,5 L21.7999996,5 L21.7999996,10.6006192 L27.3999996,10.6006192 L27.3999996,13.4004128 Z M12,20.87 C7.101,20.87 3.13,16.898 3.13,12 C3.13,7.102 7.101,3.13 12,3.13 C12.091,3.13 12.181,3.139 12.272,3.142 C9.866,5.336 8.347,8.487 8.347,12 C8.347,15.512 9.866,18.662 12.271,20.857 C12.18,20.859 12.091,20.87 12,20.87 Z M20.347,0 C18.882,0 17.484,0.276 16.186,0.756 C14.882,0.271 13.473,0 12,0 C5.372,0 0,5.373 0,12 C0,18.628 5.372,24 12,24 C13.471,24 14.878,23.726 16.181,23.242 C17.481,23.724 18.88,24 20.347,24 C26.975,24 32.347,18.628 32.347,12 C32.347,5.373 26.975,0 20.347,0 Z\"/></svg></a>\n\t\t<small class=\"share-link-info\">The link has been copied!</small> -->\n\t</div>\n\t<input type=\"text\" value=\"https://blog.n8n.io/the-good-the-bad-and-the-ugly-of-looping-with-n8n/\" id=\"copy-link\" aria-label=\"Copy link input\">\n</div>",
  "readme": "This post will cover three possible approaches to creating loops in n8n by building a web scraping workflow with paging support. With these three examples under your belt, you will better understand how looping can be used to our advantage when solving repetitive problems in n8n.\n\nWe will also cover a bit of n8n internals that can come in handy in any n8n workflow, looped or not.\n\nIf you are a developer and you already have a good handle on loops, this text will hopefully help you map your existing programming knowledge to n8n concepts. \n\n## What is looping, when and how to use it?\n\nBefore you jump on a chat with your favorite AI chatbot with the same question, let's clarify here what we consider looping in the context of n8n workflow and what are some use cases where we can take advantage of such a mechanism.\n\n[Looping in n8n](https://docs.n8n.io/flow-logic/looping/?ref=blog.n8n.io) is a way of creating workflows so **data flow (embodied in n8n connection lines) goes through one or more nodes multiple times.** Each loop execution is called an _iteration_ or a _step_ , so we'll use these terms interchangeably throughout this post.\n\nAt the start of your journey to becoming an n8n hero, it's easy to think of workflows as one-way streams which take our input data, manipulate it and spit out some results. But imagine a scenario where we must employ a set of nodes to do a particular task multiple times. If it's just a few nodes that need to be run a couple of times, our first hunch would be to copy them after the original set and be done with it. On the other hand, copying and pasting the same 15 nodes tens of times is probably not the most efficient way to build workflows (not to mention a case where you cannot know the number of iterations in advance).\n\nThat's where loops come in.\n\n**Creating loops in our workflow enables us to reuse a set of nodes multiple times with different input data each time they are executed**. Before going any further with the theory, in case you still haven't got a clear picture in your head, this is what a simple (one-node) loop looks like in the n8n workflow:\n\n![A simple loop](https://blog.n8n.io/content/images/2023/05/1_loop_example.png)_A simple loop_\n\nHere are some examples of workflows where looping is the best tool for the given task:\n\n  * Scraping web pages that use pagination to display all items,\n  * Implementing process with a maximum number of retries (like user login or checking if an API server is online),\n  * Generating patterns or sequences (e.g., custom slack message for each user in a Google Sheet),\n  * Finding a particular element (like an email with a specific subject) of a list (the inbox).\n\n\n\nAs mentioned in the introduction, we will solve the problem of scraping a paginated web page in this post, but before we get our hands dirty, let's take a look at the anatomy of a loop:\n\n![Anatomy of a loop](https://blog.n8n.io/content/images/2023/05/2_loop_anatomy.png)_Anatomy of a loop_\n\nThe image above shows the most critical steps in each loop, but as will be shown in scraping implementation, the order and performance of each of those steps can vary based on the use case.\n\nAnyhow, here are the main elements of a loop:\n\n  * Input data: We can see each loop as a separate mini-workflow with inputs and outputs. **The main difference here is that loops usually feed the modified information back to the start of the loop, making each iteration work with different data**. This last part is where the magic of looping happens since going over the same set of nodes with the same input each time is rarely helpful.\n  * Loop logic: This is the set of nodes that performs tasks in each iteration.\n  * Loop condition: When creating a looping flow, we must decide which rules determine if our loop will start a new step or stop looping and continue with the rest of the workflow. We must check these conditions in each iteration to avoid endless loops, making our workflow run indefinitely and likely crash our n8n instance.\n\n\n\n## Task description: building a web scraping workflow with paging support\n\nOur web scraping workflow will use an [example page](https://webscraper.io/test-sites/e-commerce/static/phones/touch?ref=blog.n8n.io) from [www.webscraper.io](http://www.webscraper.io/?ref=blog.n8n.io) as a safe playground for the demonstration.\n\nBy looking at the first page of this webshop, we can see that it shows only a portion of all products, so to get all of them, our workflow needs to scrape data from each page, one by one. Since all pages have the same structure, we can use the same set of n8n nodes to extract the data and create a loop to run that set for each product page. \n\nCurrently, there are only two pages in the shop, but since we cannot rely on that being always the case (products come and go in webshops constantly), our workflow will also need to detect if there are more pages to scrape before starting a new iteration. We will discuss each of those problems in greater detail as we build our workflows and move on to making stuff with n8n.\n\nIf you want to build upon this experience and start scraping data from a real-world website, please ensure that website authors enable scrapping and read [web scrapping best practices](https://blog.n8n.io/how-to-scrape-data-from-a-website/) post on our blog.\n\n## The Ugly: Using nodes to implement looping\n\nIn the first approach to web scraping using n8n, we will manually build and maintain all our looping logic using [_Set_ nodes](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.set/?ref=blog.n8n.io). Before we dissect each node individually, here's what the complete workflow looks like:\n\n![Workflow 1: The Ugly](https://blog.n8n.io/content/images/2023/05/8_the_ugly.png)Workflow 1: The Ugly\n\nOur workflow starts with [a _Manual Trigger_ node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.manualworkflowtrigger/?ref=blog.n8n.io) followed by a _Set_ node that sets the page number to 1. This number will be used as an input for [the _HTTP_ node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.httprequest/?ref=blog.n8n.io) and will change as we progress through subsequent pages.\n\n![Set Node](https://blog.n8n.io/content/images/2023/05/3_ugly-set_node-1.png)_Set Node_\n\nThe meat of this process is fetching and processing (scraping) each page, which is implemented using the _HTTP Request_ and the _HTML_ nodes. To get the first product page, we need to add an _HTTP Request_ node configured to send a GET request to the following URL (remember to use expression mode when specifying URL so the correct page number is used instead of a variable):\n\n`https://webscraper.io/test-sites/e-commerce/static/phones/touch?page={{ $json.page }}`\n\n![HTTP Request Node](https://blog.n8n.io/content/images/2023/05/4_ugly-http_node.png)_HTTP Request Node_\n\nAfter that, we can add an _HTML_ node and set it up to extract (so choose _Extract HTML Content_ as an action when adding the node) the following data from the web page:\n\n  1. Each product details. For simplicity's sake, we will only extract the product name,\n  2. Current page. We will use this to move on to the current page in the shop.\n\n\n\nWe can set this node to return this data in _**products**_ and _**currentPage**_ properties, respectively, by configuring it the following way:\n\n![HTML Node](https://blog.n8n.io/content/images/2023/05/5_ugly-html_node.png)_HTML Node_\n\nWith this in place, we have our loop input data and logic, and it's time to add the condition before we create the actual looping connection.\n\nLooking at each product page, we can see that the full list displays exactly six products while the last one contains fewer. We can use that knowledge to check if we are on the last page by testing the number of products scraped on each of them. We will assume that the first page with fewer than six products is the last in the shop. There are more robust ways of detecting the last page, but this method will enable us to implement our paging without juggling more data in additional nodes.\n\nWe will impose our loop condition by adding an IF node before our connection loops back to the input of the _HTTP Request_ node. This _IF_ node has one _Number_ condition which checks if _**{{ $json.products.length }}**_ is smaller than the number 6:\n\n![IF Node](https://blog.n8n.io/content/images/2023/05/6_ugly-if_node.png)_IF Node_\n\nIf this is not the case, we need to proceed with scraping the next page, which we will do by connecting a _**false**_ output branch of the _IF_ node to a new _Set_ node, increasing the page number by one, and looping it back to our _HTTP Request_ node.\n\nThe following image shows this new _Set_ node and its parameter values:\n\n![Set Node](https://blog.n8n.io/content/images/2023/05/7_ugly-set_node.png)_Set Node_\n\nCongrats! You just created a loop in n8n!\n\nNow, this workflow's job is done when our condition from the _IF_ node resolves as _**true**_. We won't go into details of what should happen then, but you'll notice that the complete workflow has a _Code_ node at the end, which uses a bit of n8n trickery to get the list of all scrapped products (a bit more on that at the end of this post).\n\n## The Bad: Utilizing workflow static data\n\nThe loop implemented in this example is very similar to the previous one, with two significant differences:\n\n  1. Instead of parsing the current page number from the scrapped web page, we will store it in our [workflow static data](https://docs.n8n.io/code-examples/methods-variables-examples/get-workflow-static-data/?ref=blog.n8n.io). You can think about the workflow static data as a secret storage inside each workflow which can be accessed from within your _Code_ nodes and expressions, and it enables us to store, read, and update values (numbers, strings, dates, etc.) that are of interest for the current workflow. This will provide access to the stored data directly in the nodes that need it instead of unnecessarily passing the values around the workflow.\n  2. We will use pagination HTML elements to determine the number of pages that need to be scrapped and to check if we have reached the last page. This will ensure our scraping algorithm works in case the last page contains the same number of products as the rest.\n\n\n\nHere's what this workflow looks like after everything is put together:  \n\n\n![Workflow 2: The Bad](https://blog.n8n.io/content/images/2023/05/12_the_bad.png)__Workflow 2: The Bad__\n\nA possible downside is that it relies on coding more than the previous one, but, as will be shown, it requires only a few lines of JavaScript to get everything running. Most nodes are the same as in the first example, so we won't go into the weeds when going over this method.\n\nWe start our workflow with a _Code_ node, set to run once for all items and containing the following piece of code (don't forget to add a trigger node as a first step!):\n    \n    \n    const workflowStaticData = $getWorkflowStaticData('global');\n    let currentPage = workflowStaticData.currentPage;\n    \n    if (currentPage) {\n      currentPage = currentPage + 1;\n    } else {\n      currentPage = 1;\n    }\n    return {\n     json: {\n       page: currentPage,\n     }\n    }\n    \n\nIf you are not so fluent in JavaScript, here's the translation: it tries to get the _**pageNumber**_ value from the _**global**_ workflow static data store and, if it's found, increments it by one (which moves to scrape the following product page). If there is no such value, which is the case when the workflow runs for the first time, it will set it to 1.\n\nThe next step is to fetch the current product page using the _HTTP Request_ node. We can accomplish this by setting this node up exactly as we did in the first example:\n\n![HTTP Request Node](https://blog.n8n.io/content/images/2023/05/9_bad-http_node.png)_HTTP Request Node_\n\nMoving on, we again need the _HTML_ node to extract the data we need from each product page. As mentioned, we want to parse out our current page, the total number of pages, and each product's data. So, in this case, our _HTML_ node is set up the following way:\n\n![HTML Node](https://blog.n8n.io/content/images/2023/05/10_bad-html_node.png)_HTML Node_\n\nOnce we have processed the product page, it's time to decide if we need to repeat the process for the next page or if it reached the last page. This time, we have both the current page number and the total page count, so this boils down to adding an _IF_ node that compares the two:\n\n![IF Node](https://blog.n8n.io/content/images/2023/05/11_bad-if_node.png)_IF Node_\n\nNotice that we are subtracting number 2 from the pagination element count since the first and last pagination elements are used to jump to the list's beginning and end and are not individual page links. After this, if we still are not on the last page, we store the current page number inside our workflow static data store using the new _Code_ node:\n    \n    \n    const workflowStaticData = $getWorkflowStaticData('global');\n    workflowStaticData.currentPage = parseInt($input.first().json.currentPage);\n    return {}\n    \n\nAnd finally, it's time to connect this new _Code_ node back to the first one we created earlier, which will increment the stored number and start the scrapping process for the next page.\n\n## The Good: Leveraging runtime data to keep track of iterations\n\nStill around? Good.\n\nIt's time for the last and most streamlined approach to implement looping in n8n. Here, we will take advantage of a little n8n internal mechanism to keep track of the product page we are currently on.\n\nAs usual, the entire workflow is shown below, where you can see the nice clean loop it makes:\n\n![Workflow 3: The Good](https://blog.n8n.io/content/images/2023/05/15_the_good.png)_Workflow 3: The Good_\n\nWhen observing workflows as they execute, you may have noticed a small number appearing in each node's bottom-right corner as they are run. That number is called the node's run index and counts the time the node executes within the current workflow execution. Exactly what we need for our page counting!\n\nOn top of that, run indexes are available to use in expressions with the special _**$runIndex**_ keyword. With this in mind, we can construct a workflow very similar to the one from the previous example, but now we can use the run index as a current page number and get rid of both _Code_ nodes.\n\nAs the first step, we will use a _Set_ node that outputs one value (called page) which is a run index incremented by one (this is needed since run indexes start with zero in n8n):\n\n![Set Node](https://blog.n8n.io/content/images/2023/05/13_good-set_node.png)_Set Node_\n\nAfter this, _HTTP Request_ and _HTML_ Nodes are the same as in the example before, with the difference that we don't need to scrape the current page in the _HTML_ node (just products and pagination elements):\n\n![HTML Node](https://blog.n8n.io/content/images/2023/05/14_good-html_node.png)_HTML Node_\n\nAfter the _HTML_ node, we will add our trusty _IF_ node to check if we are on the last page. We will test if the current page number _**($runIndex)** _is smaller than the total product page count _**($json.pagination.length - 2)**_. If this is true, we will create our loop by connecting the _**true**_ output branch from our _IF_ node back to the input of the _Set_ node. That's it. No nodes in between are needed!\n\n![IF Node](https://blog.n8n.io/content/images/2023/05/16_good_if_node.png)_IF Node_\n\nAnd one last trick for the end. Now that you have processed all the pages, we can only see the data from the last page in our workflow input. But fear not; the cool thing about n8n is that we can access each node's data from every iteration it runs. This is exactly what the _List all products_ node that you saw in complete workflows is doing. Here's the code it contains:\n    \n    \n    let pageCount = $node['Scrape data from the page'].runIndex;\n    let allProducts = [];\n    \n    for (let index = 0; index <= pageCount; index++) {\n      allProducts = allProducts.concat($items('Scrape data from the page', 0, index));\n    };\n    \n    return allProducts;\n    \n\n## Wrap up\n\nIn this post, we covered three ways of creating loops in n8n workflow to scrape data from a website:\n\n  1. By creating and maintaining loop data using _Set_ nodes,\n  2. By making use of workflow static data and\n  3. By utilizing the node's run index to keep track of loop iterations.\n\n\n\nThese are not the only approaches to creating loops in n8n but will serve as good guidelines for solving your future automation problems that require looping. Also, we looked at some advanced n8n techniques and internals that, we hope, will come in handy in your prospective n8n journey.  \n\n\nRegister your [n8n account in the cloud](https://n8n.io/cloud/?ref=blog.n8n.io) and start automating for free. You can also [run n8n on your server](https://docs.n8n.io/hosting/?ref=blog.n8n.io) or [download it on your computer](https://app.n8n.cloud/register?ref=blog.n8n.io)!\n\n  \n\n\n  \n\n\n  \n\n\n## Subscribe to n8n newsletter\n\nGet the best, coolest, and latest in automation and low-code delivered to your inbox each week. \n\nSomething went wrong. Please try again later.\n\nSubscribed!\n\nSubscribe\n\n[](https://twitter.com/intent/tweet?text=The%20Good%2C%20the%20Bad%2C%20and%20the%20Ugly%20of%20looping%20with%20n8n&url=https://blog.n8n.io/the-good-the-bad-and-the-ugly-of-looping-with-n8n/) [](https://www.facebook.com/sharer/sharer.php?u=https://blog.n8n.io/the-good-the-bad-and-the-ugly-of-looping-with-n8n/)\n",
  "crawled_at": "2025-05-28T10:57:22.113772"
}